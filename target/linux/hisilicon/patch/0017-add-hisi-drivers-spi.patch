diff -ruN linux-4.9.37_original/drivers/spi/spi.c linux-4.9.37_modified/drivers/spi/spi.c
--- linux-4.9.37_original/drivers/spi/spi.c	2017-07-12 16:42:41.000000000 +0300
+++ linux-4.9.37_modified/drivers/spi/spi.c	2018-07-04 07:50:03.095724580 +0300
@@ -323,11 +323,125 @@
 	return 0;
 }
 
+#ifdef CONFIG_PM_SLEEP
+static int spi_legacy_suspend(struct device *dev, pm_message_t message)
+{
+	int			value = 0;
+	struct spi_driver	*drv = to_spi_driver(dev->driver);
+
+	/* suspend will stop irqs and dma; no more i/o */
+	if (drv) {
+		if (drv->suspend)
+			value = drv->suspend(to_spi_device(dev), message);
+		else
+			dev_dbg(dev, "... can't suspend\n");
+	}
+	return value;
+}
+
+static int spi_legacy_resume(struct device *dev)
+{
+	int			value = 0;
+	struct spi_driver	*drv = to_spi_driver(dev->driver);
+
+	/* resume may restart the i/o queue */
+	if (drv) {
+		if (drv->resume)
+			value = drv->resume(to_spi_device(dev));
+		else
+			dev_dbg(dev, "... can't resume\n");
+	}
+	return value;
+}
+
+static int spi_pm_suspend(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_suspend(dev);
+	else
+		return spi_legacy_suspend(dev, PMSG_SUSPEND);
+}
+
+static int spi_pm_resume(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_resume(dev);
+	else
+		return spi_legacy_resume(dev);
+}
+
+static int spi_pm_freeze(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_freeze(dev);
+	else
+		return spi_legacy_suspend(dev, PMSG_FREEZE);
+}
+
+static int spi_pm_thaw(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_thaw(dev);
+	else
+		return spi_legacy_resume(dev);
+}
+
+static int spi_pm_poweroff(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_poweroff(dev);
+	else
+		return spi_legacy_suspend(dev, PMSG_HIBERNATE);
+}
+
+static int spi_pm_restore(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_restore(dev);
+	else
+		return spi_legacy_resume(dev);
+}
+#else
+#define spi_pm_suspend	NULL
+#define spi_pm_resume	NULL
+#define spi_pm_freeze	NULL
+#define spi_pm_thaw	NULL
+#define spi_pm_poweroff	NULL
+#define spi_pm_restore	NULL
+#endif
+
+static const struct dev_pm_ops spi_pm = {
+	.suspend = spi_pm_suspend,
+	.resume = spi_pm_resume,
+	.freeze = spi_pm_freeze,
+	.thaw = spi_pm_thaw,
+	.poweroff = spi_pm_poweroff,
+	.restore = spi_pm_restore,
+	SET_RUNTIME_PM_OPS(
+		pm_generic_runtime_suspend,
+		pm_generic_runtime_resume,
+		NULL
+	)
+};
+
 struct bus_type spi_bus_type = {
 	.name		= "spi",
 	.dev_groups	= spi_dev_groups,
 	.match		= spi_match_device,
 	.uevent		= spi_uevent,
+	.pm		= &spi_pm,
 };
 EXPORT_SYMBOL_GPL(spi_bus_type);
 
diff -ruN linux-4.9.37_original/drivers/spi/spi-pl022.c linux-4.9.37_modified/drivers/spi/spi-pl022.c
--- linux-4.9.37_original/drivers/spi/spi-pl022.c	2017-07-12 16:42:41.000000000 +0300
+++ linux-4.9.37_modified/drivers/spi/spi-pl022.c	2018-07-04 07:50:03.095724580 +0300
@@ -43,6 +43,7 @@
 #include <linux/gpio.h>
 #include <linux/of_gpio.h>
 #include <linux/pinctrl/consumer.h>
+#include <linux/of_address.h>
 
 /*
  * This macro is used to define some register default values.
@@ -137,6 +138,13 @@
 #define SSP_CR1_MASK_FBCLKDEL_ST (0x7UL << 13)
 
 /*
+ * The Hisilicon version of this block adds some bits
+ * in SSP_CR1
+ */
+#define SSP_CR1_MASK_BIGEND_HISI	(0x1UL << 4)
+#define SSP_CR1_MASK_ALTASENS_HISI	(0x1UL << 6)
+
+/*
  * SSP Status Register - SSP_SR
  */
 #define SSP_SR_MASK_TFE		(0x1UL << 0) /* Transmit FIFO empty */
@@ -296,6 +304,8 @@
 
 #define SPI_POLLING_TIMEOUT 1000
 
+#define PL022_IDS_INDEX_HISI		4
+
 /*
  * The type of reading going on on this chip
  */
@@ -337,6 +347,13 @@
 	bool internal_cs_ctrl;
 };
 
+struct cs_data {
+	struct resource		res;
+	void __iomem		*virt_addr;
+	unsigned int		cs_sb;
+	unsigned int		cs_mask_bit;
+};
+
 /**
  * struct pl022 - This is the private SSP driver data structure
  * @adev: AMBA device model hookup
@@ -346,6 +363,13 @@
  * @clk: outgoing clock "SPICLK" for the SPI bus
  * @master: SPI framework hookup
  * @master_info: controller-specific data from machine setup
+ * @kworker: thread struct for message pump
+ * @kworker_task: pointer to task for message pump kworker thread
+ * @pump_messages: work struct for scheduling work to the message pump
+ * @queue_lock: spinlock to syncronise access to message queue
+ * @queue: message queue
+ * @busy: message pump is busy
+ * @running: message pump is running
  * @pump_transfers: Tasklet used in Interrupt Transfer mode
  * @cur_msg: Pointer to current spi_message being processed
  * @cur_transfer: Pointer to current spi_transfer
@@ -403,6 +427,7 @@
 #endif
 	int cur_cs;
 	int *chipselects;
+	struct cs_data		*cs_data;
 };
 
 /**
@@ -459,13 +484,37 @@
 static void internal_cs_control(struct pl022 *pl022, u32 command)
 {
 	u32 tmp;
-
-	tmp = readw(SSP_CSR(pl022->virtbase));
-	if (command == SSP_CHIP_SELECT)
-		tmp &= ~BIT(pl022->cur_cs);
-	else
-		tmp |= BIT(pl022->cur_cs);
-	writew(tmp, SSP_CSR(pl022->virtbase));
+	struct amba_device *adev = pl022->adev;
+	struct amba_driver *adrv = container_of(adev->dev.driver,
+			struct amba_driver, drv);
+
+	if (pl022->vendor->extended_cr && (adev->periphid ==
+				adrv->id_table[PL022_IDS_INDEX_HISI].id)) {
+		if (pl022->cs_data) {
+			tmp = readl(pl022->cs_data->virt_addr);
+			tmp &= ~(pl022->cs_data->cs_mask_bit);
+			tmp |= ((u32)pl022->cur_cs) << pl022->cs_data->cs_sb;
+			writel(tmp, pl022->cs_data->virt_addr);
+		}
+
+		if (command == SSP_CHIP_SELECT)
+			/* Enable SSP */
+			writew((readw(SSP_CR1(pl022->virtbase)) |
+						SSP_CR1_MASK_SSE),
+					SSP_CR1(pl022->virtbase));
+		else
+			/* disable SSP */
+			writew((readw(SSP_CR1(pl022->virtbase)) &
+						(~SSP_CR1_MASK_SSE)),
+					SSP_CR1(pl022->virtbase));
+	} else {
+		tmp = readw(SSP_CSR(pl022->virtbase));
+		if (command == SSP_CHIP_SELECT)
+			tmp &= ~BIT((u32)pl022->cur_cs);
+		else
+			tmp |= BIT((u32)pl022->cur_cs);
+		writew(tmp, SSP_CSR(pl022->virtbase));
+	}
 }
 
 static void pl022_cs_control(struct pl022 *pl022, u32 command)
@@ -566,8 +615,12 @@
 static void restore_state(struct pl022 *pl022)
 {
 	struct chip_data *chip = pl022->cur_chip;
+	struct amba_device *adev = pl022->adev;
+	struct amba_driver *adrv = container_of(adev->dev.driver,
+			struct amba_driver, drv);
 
-	if (pl022->vendor->extended_cr)
+	if (pl022->vendor->extended_cr && (adev->periphid !=
+				adrv->id_table[PL022_IDS_INDEX_HISI].id))
 		writel(chip->cr0, SSP_CR0(pl022->virtbase));
 	else
 		writew(chip->cr0, SSP_CR0(pl022->virtbase));
@@ -640,6 +693,13 @@
 	GEN_MASK_BITS(SSP_FEEDBACK_CLK_DELAY_NONE, SSP_CR1_MASK_FBCLKDEL_ST, 13) \
 )
 
+/* Hisilicon versions extend this register to use all 16 bits */
+#define DEFAULT_SSP_REG_CR1_HISI ( \
+	DEFAULT_SSP_REG_CR1 | \
+	GEN_MASK_BITS(SSP_RX_MSB, SSP_CR1_MASK_BIGEND_HISI, 4) | \
+	GEN_MASK_BITS(0x1, SSP_CR1_MASK_ALTASENS_HISI, 6) \
+)
+
 #define DEFAULT_SSP_REG_CPSR ( \
 	GEN_MASK_BITS(SSP_DEFAULT_PRESCALE, SSP_CPSR_MASK_CPSDVSR, 0) \
 )
@@ -655,12 +715,24 @@
  */
 static void load_ssp_default_config(struct pl022 *pl022)
 {
+	struct amba_device *adev = pl022->adev;
+	struct amba_driver *adrv = container_of(adev->dev.driver,
+			struct amba_driver, drv);
+
 	if (pl022->vendor->pl023) {
 		writel(DEFAULT_SSP_REG_CR0_ST_PL023, SSP_CR0(pl022->virtbase));
 		writew(DEFAULT_SSP_REG_CR1_ST_PL023, SSP_CR1(pl022->virtbase));
 	} else if (pl022->vendor->extended_cr) {
-		writel(DEFAULT_SSP_REG_CR0_ST, SSP_CR0(pl022->virtbase));
-		writew(DEFAULT_SSP_REG_CR1_ST, SSP_CR1(pl022->virtbase));
+		if (adev->periphid == adrv->id_table[PL022_IDS_INDEX_HISI].id) {
+			writew(DEFAULT_SSP_REG_CR0, SSP_CR0(pl022->virtbase));
+			writew(DEFAULT_SSP_REG_CR1_HISI,
+					SSP_CR1(pl022->virtbase));
+		} else {
+			writel(DEFAULT_SSP_REG_CR0_ST,
+					SSP_CR0(pl022->virtbase));
+			writew(DEFAULT_SSP_REG_CR1_ST,
+					SSP_CR1(pl022->virtbase));
+		}
 	} else {
 		writew(DEFAULT_SSP_REG_CR0, SSP_CR0(pl022->virtbase));
 		writew(DEFAULT_SSP_REG_CR1, SSP_CR1(pl022->virtbase));
@@ -1835,6 +1907,10 @@
 	unsigned int bits = spi->bits_per_word;
 	u32 tmp;
 	struct device_node *np = spi->dev.of_node;
+	struct amba_device *adev = pl022->adev;
+	struct amba_driver *adrv = container_of(adev->dev.driver,
+			struct amba_driver, drv);
+
 
 	if (!spi->max_speed_hz)
 		return -EINVAL;
@@ -1977,7 +2053,8 @@
 	chip->cpsr = clk_freq.cpsdvsr;
 
 	/* Special setup for the ST micro extended control registers */
-	if (pl022->vendor->extended_cr) {
+	if (pl022->vendor->extended_cr && (adev->periphid !=
+				adrv->id_table[PL022_IDS_INDEX_HISI].id)) {
 		u32 etx;
 
 		if (pl022->vendor->pl023) {
@@ -2011,6 +2088,20 @@
 			       SSP_CR1_MASK_RXIFLSEL_ST, 7);
 		SSP_WRITE_BITS(chip->cr1, chip_info->tx_lev_trig,
 			       SSP_CR1_MASK_TXIFLSEL_ST, 10);
+	} else if (pl022->vendor->extended_cr && (adev->periphid ==
+				adrv->id_table[PL022_IDS_INDEX_HISI].id)) {
+		SSP_WRITE_BITS(chip->cr0, bits - 1,
+			       SSP_CR0_MASK_DSS, 0);
+		SSP_WRITE_BITS(chip->cr0, chip_info->iface,
+			       SSP_CR0_MASK_FRF, 4);
+
+		if (spi->mode & SPI_LSB_FIRST)
+			tmp = !!SPI_LSB_FIRST;
+		else
+			tmp = !SPI_LSB_FIRST;
+
+		SSP_WRITE_BITS(chip->cr1, tmp, SSP_CR1_MASK_BIGEND_HISI, 4);
+		SSP_WRITE_BITS(chip->cr1, 0x1, SSP_CR1_MASK_ALTASENS_HISI, 6);
 	} else {
 		SSP_WRITE_BITS(chip->cr0, bits - 1,
 			       SSP_CR0_MASK_DSS, 0);
@@ -2042,7 +2133,7 @@
 	}
 	SSP_WRITE_BITS(chip->cr1, SSP_DISABLED, SSP_CR1_MASK_SSE, 1);
 	SSP_WRITE_BITS(chip->cr1, chip_info->hierarchy, SSP_CR1_MASK_MS, 2);
-	SSP_WRITE_BITS(chip->cr1, chip_info->slave_tx_disable, SSP_CR1_MASK_SOD,
+	SSP_WRITE_BITS(chip->cr1, (unsigned int)chip_info->slave_tx_disable, SSP_CR1_MASK_SOD,
 		3);
 
 	/* Save controller_state */
@@ -2074,7 +2165,7 @@
 {
 	struct device_node *np = dev->of_node;
 	struct pl022_ssp_controller *pd;
-	u32 tmp;
+	u32 tmp = 0;
 
 	if (!np) {
 		dev_err(dev, "no dt node defined\n");
@@ -2099,6 +2190,8 @@
 static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
 {
 	struct device *dev = &adev->dev;
+	struct amba_driver *adrv = container_of(adev->dev.driver,
+			struct amba_driver, drv);
 	struct pl022_ssp_controller *platform_info =
 			dev_get_platdata(&adev->dev);
 	struct spi_master *master;
@@ -2162,6 +2255,41 @@
 	} else if (pl022->vendor->internal_cs_ctrl) {
 		for (i = 0; i < num_cs; i++)
 			pl022->chipselects[i] = i;
+
+		if ((adev->periphid == adrv->id_table[PL022_IDS_INDEX_HISI].id)
+				&& pl022->vendor->extended_cr
+				&& (num_cs > 1)) {
+			pl022->cs_data = devm_kzalloc(dev,
+					sizeof(struct cs_data),
+					GFP_KERNEL);
+			if (!pl022->cs_data) {
+				status = -ENOMEM;
+				goto err_no_mem;
+			}
+
+			if (of_address_to_resource(np, 1,
+						&pl022->cs_data->res)) {
+				status = -EPROBE_DEFER;
+				goto err_no_gpio;
+			}
+
+			if (of_property_read_u32(np, "hisi,spi_cs_sb",
+						&pl022->cs_data->cs_sb)) {
+				status = -EPROBE_DEFER;
+				goto err_no_gpio;
+			}
+
+			if (of_property_read_u32(np, "hisi,spi_cs_mask_bit",
+						&pl022->cs_data->cs_mask_bit)) {
+				status = -EPROBE_DEFER;
+				goto err_no_gpio;
+			}
+
+			pl022->cs_data->virt_addr = devm_ioremap(dev,
+					pl022->cs_data->res.start,
+					resource_size(&adev->res));
+		} else
+				pl022->cs_data = NULL;
 	} else if (IS_ENABLED(CONFIG_OF)) {
 		for (i = 0; i < num_cs; i++) {
 			int cs_gpio = of_get_named_gpio(np, "cs-gpios", i);
@@ -2288,6 +2416,10 @@
  err_no_ioremap:
 	amba_release_regions(adev);
  err_no_ioregion:
+	if (pl022->cs_data)
+		release_mem_region(pl022->cs_data->res.start,
+				resource_size(&pl022->cs_data->res));
+
  err_no_gpio:
  err_no_mem:
 	spi_master_put(master);
@@ -2314,6 +2446,10 @@
 
 	clk_disable_unprepare(pl022->clk);
 	amba_release_regions(adev);
+	if (pl022->cs_data)
+		release_mem_region(pl022->cs_data->res.start,
+				resource_size(&pl022->cs_data->res));
+
 	tasklet_disable(&pl022->pump_transfers);
 	return 0;
 }
@@ -2429,6 +2565,16 @@
 	.internal_cs_ctrl = true,
 };
 
+static struct vendor_data vendor_hisi = {
+	.fifodepth = 256,
+	.max_bpw = 16,
+	.unidir = false,
+	.extended_cr = true,
+	.pl023 = false,
+	.loopback = true,
+	.internal_cs_ctrl = true,
+};
+
 static struct amba_id pl022_ids[] = {
 	{
 		/*
@@ -2469,6 +2615,15 @@
 		.mask	= 0x000fffff,
 		.data	= &vendor_lsi,
 	},
+	{
+		/*
+		 * Hisilicon derivative, this has a 16bit wide
+		 * and 256 locations deep TX/RX FIFO
+		 */
+		.id	= 0x00800022,
+		.mask	= 0xffffffff,
+		.data	= &vendor_hisi,
+	},
 	{ 0, 0 },
 };
 
