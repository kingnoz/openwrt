diff -ruN linux-4.9.37_original/drivers/usb/gadget/function/f_mass_storage.c linux-4.9.37_modified/drivers/usb/gadget/function/f_mass_storage.c
--- linux-4.9.37_original/drivers/usb/gadget/function/f_mass_storage.c	2017-07-12 16:42:41.000000000 +0300
+++ linux-4.9.37_modified/drivers/usb/gadget/function/f_mass_storage.c	2018-07-04 07:50:03.099724621 +0300
@@ -253,6 +253,7 @@
 
 struct fsg_dev;
 struct fsg_common;
+extern void hisi_switch_func(int otg);
 
 /* Data shared by all the FSG instances. */
 struct fsg_common {
@@ -1952,6 +1953,9 @@
 				      "READ CAPACITY");
 		if (reply == 0)
 			reply = do_read_capacity(common, bh);
+
+		hisi_switch_func(1);
+
 		break;
 
 	case READ_HEADER:
@@ -1995,6 +1999,9 @@
 				      "REQUEST SENSE");
 		if (reply == 0)
 			reply = do_request_sense(common, bh);
+
+		hisi_switch_func(1);
+
 		break;
 
 	case START_STOP:
diff -ruN linux-4.9.37_original/drivers/usb/gadget/udc/core.c linux-4.9.37_modified/drivers/usb/gadget/udc/core.c
--- linux-4.9.37_original/drivers/usb/gadget/udc/core.c	2017-07-12 16:42:41.000000000 +0300
+++ linux-4.9.37_modified/drivers/usb/gadget/udc/core.c	2018-07-04 07:50:03.099724621 +0300
@@ -905,11 +905,6 @@
 	type = usb_endpoint_type(desc);
 	max = 0x7ff & usb_endpoint_maxp(desc);
 
-	if (usb_endpoint_dir_in(desc) && !ep->caps.dir_in)
-		return 0;
-	if (usb_endpoint_dir_out(desc) && !ep->caps.dir_out)
-		return 0;
-
 	if (max > ep->maxpacket_limit)
 		return 0;
 
@@ -929,8 +924,6 @@
 			return 0;
 		break;
 	case USB_ENDPOINT_XFER_BULK:
-		if (!ep->caps.type_bulk)
-			return 0;
 		if (ep_comp && gadget_is_superspeed(gadget)) {
 			/* Get the number of required streams from the
 			 * EP companion descriptor and see if the EP
@@ -967,15 +960,6 @@
 	if (udc)
 		sysfs_notify(&udc->dev.kobj, NULL, "state");
 }
-
-void usb_gadget_set_state(struct usb_gadget *gadget,
-		enum usb_device_state state)
-{
-	gadget->state = state;
-	schedule_work(&gadget->work);
-}
-EXPORT_SYMBOL_GPL(usb_gadget_set_state);
-
 /* ------------------------------------------------------------------------- */
 
 static void usb_udc_connect_control(struct usb_udc *udc)
@@ -986,6 +970,24 @@
 		usb_gadget_disconnect(udc->gadget);
 }
 
+/* should be called with udc_lock held */
+static int check_pending_gadget_drivers(struct usb_udc *udc)
+{
+       struct usb_gadget_driver *driver;
+       int ret = 0;
+
+       list_for_each_entry(driver, &gadget_driver_pending_list, pending)
+               if (!driver->udc_name || strcmp(driver->udc_name,
+                                               dev_name(&udc->dev)) == 0) {
+                       ret = udc_bind_to_driver(udc, driver);
+                       if (ret != -EPROBE_DEFER)
+                               list_del(&driver->pending);
+                       break;
+               }
+
+       return ret;
+}
+
 /**
  * usb_udc_vbus_handler - updates the udc core vbus status, and try to
  * connect or disconnect gadget
@@ -1006,6 +1008,15 @@
 }
 EXPORT_SYMBOL_GPL(usb_udc_vbus_handler);
 
+/* ------------------------------------------------------------------------- */
+void usb_gadget_set_state(struct usb_gadget *gadget,
+                enum usb_device_state state)
+{
+        gadget->state = state;
+}
+EXPORT_SYMBOL_GPL(usb_gadget_set_state);
+/* ------------------------------------------------------------------------- */
+
 /**
  * usb_gadget_udc_reset - notifies the udc core that bus reset occurs
  * @gadget: The gadget which bus reset occurs
@@ -1081,24 +1092,6 @@
 	dev_vdbg(dev, "%s\n", __func__);
 }
 
-/* should be called with udc_lock held */
-static int check_pending_gadget_drivers(struct usb_udc *udc)
-{
-	struct usb_gadget_driver *driver;
-	int ret = 0;
-
-	list_for_each_entry(driver, &gadget_driver_pending_list, pending)
-		if (!driver->udc_name || strcmp(driver->udc_name,
-						dev_name(&udc->dev)) == 0) {
-			ret = udc_bind_to_driver(udc, driver);
-			if (ret != -EPROBE_DEFER)
-				list_del(&driver->pending);
-			break;
-		}
-
-	return ret;
-}
-
 /**
  * usb_add_gadget_udc_release - adds a new gadget to the udc class driver list
  * @parent: the parent device to this udc. Usually the controller driver's
@@ -1311,87 +1304,6 @@
 	udc->gadget->dev.driver = NULL;
 	return ret;
 }
-
-int usb_gadget_probe_driver(struct usb_gadget_driver *driver)
-{
-	struct usb_udc		*udc = NULL;
-	int			ret = -ENODEV;
-
-	if (!driver || !driver->bind || !driver->setup)
-		return -EINVAL;
-
-	mutex_lock(&udc_lock);
-	if (driver->udc_name) {
-		list_for_each_entry(udc, &udc_list, list) {
-			ret = strcmp(driver->udc_name, dev_name(&udc->dev));
-			if (!ret)
-				break;
-		}
-		if (ret)
-			ret = -ENODEV;
-		else if (udc->driver)
-			ret = -EBUSY;
-		else
-			goto found;
-	} else {
-		list_for_each_entry(udc, &udc_list, list) {
-			/* For now we take the first one */
-			if (!udc->driver)
-				goto found;
-		}
-	}
-
-	if (!driver->match_existing_only) {
-		list_add_tail(&driver->pending, &gadget_driver_pending_list);
-		pr_info("udc-core: couldn't find an available UDC - added [%s] to list of pending drivers\n",
-			driver->function);
-		ret = 0;
-	}
-
-	mutex_unlock(&udc_lock);
-	return ret;
-found:
-	ret = udc_bind_to_driver(udc, driver);
-	mutex_unlock(&udc_lock);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(usb_gadget_probe_driver);
-
-int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
-{
-	struct usb_udc		*udc = NULL;
-	int			ret = -ENODEV;
-
-	if (!driver || !driver->unbind)
-		return -EINVAL;
-
-	mutex_lock(&udc_lock);
-	list_for_each_entry(udc, &udc_list, list) {
-		if (udc->driver == driver) {
-			usb_gadget_remove_driver(udc);
-			usb_gadget_set_state(udc->gadget,
-					     USB_STATE_NOTATTACHED);
-
-			/* Maybe there is someone waiting for this UDC? */
-			check_pending_gadget_drivers(udc);
-			/*
-			 * For now we ignore bind errors as probably it's
-			 * not a valid reason to fail other's gadget unbind
-			 */
-			ret = 0;
-			break;
-		}
-	}
-
-	if (ret) {
-		list_del(&driver->pending);
-		ret = 0;
-	}
-	mutex_unlock(&udc_lock);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(usb_gadget_unregister_driver);
-
 /* ------------------------------------------------------------------------- */
 
 static ssize_t usb_udc_srp_store(struct device *dev,
