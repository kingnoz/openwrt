diff -ruN linux-4.9.37_original/drivers/mtd/Makefile linux-4.9.37_modified/drivers/mtd/Makefile
--- linux-4.9.37_original/drivers/mtd/Makefile	2017-07-12 16:42:41.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/Makefile	2018-07-04 07:50:03.075724383 +0300
@@ -30,7 +30,7 @@
 nftl-objs		:= nftlcore.o nftlmount.o
 inftl-objs		:= inftlcore.o inftlmount.o
 
+obj-$(CONFIG_MTD_SPI_NOR)	+= spi-nor/
 obj-y		+= chips/ lpddr/ maps/ devices/ nand/ onenand/ tests/
 
-obj-$(CONFIG_MTD_SPI_NOR)	+= spi-nor/
 obj-$(CONFIG_MTD_UBI)		+= ubi/
diff -ruN linux-4.9.37_original/drivers/mtd/nand/hifmc100/hifmc100.c linux-4.9.37_modified/drivers/mtd/nand/hifmc100/hifmc100.c
--- linux-4.9.37_original/drivers/mtd/nand/hifmc100/hifmc100.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/hifmc100/hifmc100.c	2018-07-04 07:50:03.075724383 +0300
@@ -0,0 +1,1167 @@
+/*
+ * The Flash Memory Controller v100 Device Driver for hisilicon
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/mtd/nand.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <asm/setup.h>
+
+#include "../hinfc_gen.h"
+#include "hifmc100_os.h"
+#include "hifmc100.h"
+#include <linux/mfd/hisi_fmc.h>
+
+/*****************************************************************************/
+static void hifmc100_switch_to_spi_nand(struct hifmc_host *host)
+{
+	int reg;
+
+	reg = hifmc_readl(host, FMC_CFG);
+	reg &= ~FLASH_TYPE_SEL_MASK;
+	reg |= FMC_CFG_FLASH_SEL(FLASH_TYPE_SPI_NAND);
+	hifmc_writel(host, FMC_CFG, reg);
+}
+
+/*****************************************************************************/
+static void hifmc100_operation_config(struct hifmc_host *host, int op)
+{
+	int ret, clkrate = 0;
+	struct hifmc_spi *spi = host->spi;
+
+	hifmc100_switch_to_spi_nand(host);
+	clk_prepare_enable(host->clk);
+	switch (op) {
+	case OP_STYPE_WRITE:
+		clkrate = min((u_long)host->clkrate,
+				 (u_long)CLK_FMC_TO_CRG_MHZ(spi->write->clock));
+		break;
+	case OP_STYPE_READ:
+		clkrate = min((u_long)host->clkrate,
+				 (u_long)CLK_FMC_TO_CRG_MHZ(spi->read->clock));
+		break;
+	case OP_STYPE_ERASE:
+		clkrate = min((u_long)host->clkrate,
+				 (u_long)CLK_FMC_TO_CRG_MHZ(spi->erase->clock));
+		break;
+	default:
+		break;
+	}
+
+	ret = clk_set_rate(host->clk, clkrate);
+	if (WARN_ON(ret))
+		pr_err("clk_set_rate failed: %d\n", ret);
+}
+
+/*****************************************************************************/
+static void hifmc100_send_cmd_write(struct hifmc_host *host)
+{
+	unsigned char pages_per_block_shift;
+	unsigned int reg, block_num, block_num_h, page_num;
+	struct hifmc_spi *spi = host->spi;
+	struct nand_chip *chip = host->chip;
+#ifdef HIFMC100_SPI_NAND_SUPPORT_REG_WRITE
+	const char *op = "Reg";
+#else
+	const char *op = "Dma";
+#endif
+
+	if (WR_DBG)
+		pr_info("\n");
+	FMC_PR(WR_DBG, "*-Start send %s page write command\n", op);
+
+	mutex_lock(host->lock);
+	hifmc100_operation_config(host, OP_STYPE_WRITE);
+
+	reg = spi->driver->wait_ready(spi);
+	if (reg) {
+		DB_MSG("Error: %s program wait ready failed! status: %#x\n",
+				op, reg);
+		goto end;
+	}
+
+	reg = spi->driver->write_enable(spi);
+	if (reg) {
+		DB_MSG("Error: %s program write enable failed! reg: %#x\n",
+				op, reg);
+		goto end;
+	}
+
+	reg = FMC_INT_CLR_ALL;
+	hifmc_writel(host, FMC_INT_CLR, reg);
+	FMC_PR(WR_DBG, "|-Set INT_CLR[%#x]%#x\n", FMC_INT_CLR, reg);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs)
+		| OP_CFG_MEM_IF_TYPE(spi->write->iftype);
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(WR_DBG, "|-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	pages_per_block_shift = chip->phys_erase_shift - chip->page_shift;
+	block_num = host->addr_value[1] >> pages_per_block_shift;
+	block_num_h = block_num >> REG_CNT_HIGH_BLOCK_NUM_SHIFT;
+	reg = FMC_ADDRH_SET(block_num_h);
+	hifmc_writel(host, FMC_ADDRH, reg);
+	FMC_PR(WR_DBG, "|-Set ADDRH[%#x]%#x\n", FMC_ADDRH, reg);
+
+	page_num = host->addr_value[1] - (block_num << pages_per_block_shift);
+	reg = ((block_num & REG_CNT_BLOCK_NUM_MASK) << REG_CNT_BLOCK_NUM_SHIFT)
+	     | ((page_num & REG_CNT_PAGE_NUM_MASK) << REG_CNT_PAGE_NUM_SHIFT);
+	hifmc_writel(host, FMC_ADDRL, reg);
+	FMC_PR(WR_DBG, "|-Set ADDRL[%#x]%#x\n", FMC_ADDRL, reg);
+
+	*host->epm = 0x0000;
+
+#ifndef HIFMC100_SPI_NAND_SUPPORT_REG_WRITE
+	reg = host->dma_buffer;
+	hifmc_writel(host, FMC_DMA_SADDR_D0, reg);
+	FMC_PR(WR_DBG, "|-Set DMA_SADDR_D[0x40]%#x\n", reg);
+
+#ifdef CONFIG_64BIT
+	reg = (host->dma_buffer & FMC_DMA_SADDRH_MASK) >> 32;
+	hifmc_writel(host, FMC_DMA_SADDRH_D0, reg);
+	FMC_PR(WR_DBG, "\t|-Set DMA_SADDRH_D0[%#x]%#x\n", FMC_DMA_SADDRH_D0, reg);
+#endif
+
+	reg = host->dma_oob;
+	hifmc_writel(host, FMC_DMA_SADDR_OOB, reg);
+	FMC_PR(WR_DBG, "|-Set DMA_SADDR_OOB[%#x]%#x\n", FMC_DMA_SADDR_OOB, reg);
+#ifdef CONFIG_64BIT
+	reg = (host->dma_oob & FMC_DMA_SADDRH_MASK) >> 32;
+	hifmc_writel(host, FMC_DMA_SADDRH_OOB, reg);
+	FMC_PR(WR_DBG, "\t|-Set DMA_SADDRH_OOB[%#x]%#x\n", FMC_DMA_SADDRH_OOB,
+			reg);
+#endif
+#endif
+
+	reg = OP_CTRL_WR_OPCODE(spi->write->cmd)
+#ifdef HIFMC100_SPI_NAND_SUPPORT_REG_WRITE
+		| OP_CTRL_DMA_OP(OP_TYPE_REG)
+#else
+		| OP_CTRL_DMA_OP(OP_TYPE_DMA)
+#endif
+		| OP_CTRL_RW_OP(RW_OP_WRITE)
+		| OP_CTRL_DMA_OP_READY;
+	hifmc_writel(host, FMC_OP_CTRL, reg);
+	FMC_PR(WR_DBG, "|-Set OP_CTRL[%#x]%#x\n", FMC_OP_CTRL, reg);
+
+	FMC_DMA_WAIT_INT_FINISH(host);
+
+end:
+	mutex_unlock(host->lock);
+	FMC_PR(WR_DBG, "*-End %s page program!\n", op);
+}
+
+/*****************************************************************************/
+static void hifmc100_send_cmd_status(struct hifmc_host *host)
+{
+	unsigned char status, addr = STATUS_ADDR;
+	struct hifmc_spi *spi = host->spi;
+
+	if (host->cmd_op.l_cmd == NAND_CMD_GET_FEATURES)
+		addr = PROTECT_ADDR;
+
+	status = spi_nand_feature_op(spi, GET_OP, addr, 0);
+	FMC_PR((ER_DBG || WR_DBG), "\t*-Get status[%#x]: %#x\n", addr, status);
+}
+
+/*****************************************************************************/
+static void hifmc100_send_cmd_read(struct hifmc_host *host)
+{
+	unsigned char pages_per_block_shift, only_oob = 0;
+	unsigned short wrap = 0;
+	unsigned int reg, block_num, block_num_h, page_num, addr_of = 0;
+	struct hifmc_spi *spi = host->spi;
+	struct nand_chip *chip = host->chip;
+#ifdef HIFMC100_SPI_NAND_SUPPORT_REG_READ
+	char *op = "Reg";
+#else
+	char *op = "Dma";
+#endif
+
+	if (RD_DBG)
+		pr_info("\n");
+	FMC_PR(RD_DBG, "\t*-Start %s page read\n", op);
+
+	if ((host->addr_value[0] == host->cache_addr_value[0])
+		&& (host->addr_value[1] == host->cache_addr_value[1])) {
+		FMC_PR(RD_DBG, "\t*-%s read cache hit, addr[%#x %#x]\n",
+			op, host->addr_value[1], host->addr_value[0]);
+		return;
+	}
+
+	mutex_lock(host->lock);
+	hifmc100_operation_config(host, OP_STYPE_READ);
+
+	FMC_PR(RD_DBG, "\t|-Wait ready before %s page read\n", op);
+	reg = spi->driver->wait_ready(spi);
+	if (reg) {
+		DB_MSG("Error: %s read wait ready fail! reg: %#x\n", op, reg);
+		goto end;
+	}
+
+	reg = FMC_INT_CLR_ALL;
+	hifmc_writel(host, FMC_INT_CLR, reg);
+	FMC_PR(RD_DBG, "\t|-Set INT_CLR[%#x]%#x\n", FMC_INT_CLR, reg);
+
+	if (host->cmd_op.l_cmd == NAND_CMD_READOOB) {
+		only_oob = 1;
+		host->cmd_op.op_cfg = OP_CTRL_RD_OP_SEL(RD_OP_READ_OOB);
+	} else
+		host->cmd_op.op_cfg = OP_CTRL_RD_OP_SEL(RD_OP_READ_ALL_PAGE);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs)
+		| OP_CFG_MEM_IF_TYPE(spi->read->iftype)
+		| OP_CFG_DUMMY_NUM(spi->read->dummy);
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(RD_DBG, "\t|-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	pages_per_block_shift = chip->phys_erase_shift - chip->page_shift;
+	block_num = host->addr_value[1] >> pages_per_block_shift;
+	block_num_h = block_num >> REG_CNT_HIGH_BLOCK_NUM_SHIFT;
+
+	reg = FMC_ADDRH_SET(block_num_h);
+	hifmc_writel(host, FMC_ADDRH, reg);
+	FMC_PR(RD_DBG, "\t|-Set ADDRH[%#x]%#x\n", FMC_ADDRH, reg);
+
+	page_num = host->addr_value[1] - (block_num << pages_per_block_shift);
+	if (only_oob)
+		switch (host->ecctype) {
+		case NAND_ECC_8BIT:
+			addr_of = REG_CNT_ECC_8BIT_OFFSET;
+			break;
+		case NAND_ECC_16BIT:
+			addr_of = REG_CNT_ECC_16BIT_OFFSET;
+			break;
+		case NAND_ECC_24BIT:
+			addr_of = REG_CNT_ECC_24BIT_OFFSET;
+			break;
+		case NAND_ECC_0BIT:
+		default:
+			break;
+		}
+
+	reg = ((block_num & REG_CNT_BLOCK_NUM_MASK) << REG_CNT_BLOCK_NUM_SHIFT)
+		| ((page_num & REG_CNT_PAGE_NUM_MASK) << REG_CNT_PAGE_NUM_SHIFT)
+		| ((wrap & REG_CNT_WRAP_MASK) << REG_CNT_WRAP_SHIFT)
+		| (addr_of & REG_CNT_ECC_OFFSET_MASK);
+	hifmc_writel(host, FMC_ADDRL, reg);
+	FMC_PR(RD_DBG, "\t|-Set ADDRL[%#x]%#x\n", FMC_ADDRL, reg);
+
+#ifndef HIFMC100_SPI_NAND_SUPPORT_REG_READ
+	reg = host->dma_buffer;
+	hifmc_writel(host, FMC_DMA_SADDR_D0, reg);
+	FMC_PR(RD_DBG, "\t|-Set DMA_SADDR_D0[%#x]%#x\n", FMC_DMA_SADDR_D0, reg);
+
+#ifdef CONFIG_64BIT
+	reg = (host->dma_buffer & FMC_DMA_SADDRH_MASK) >> 32;
+	hifmc_writel(host, FMC_DMA_SADDRH_D0, reg);
+	FMC_PR(RD_DBG, "\t|-Set DMA_SADDRH_D0[%#x]%#x\n", FMC_DMA_SADDRH_D0, reg);
+#endif
+
+	reg = host->dma_oob;
+	hifmc_writel(host, FMC_DMA_SADDR_OOB, reg);
+	FMC_PR(RD_DBG, "\t|-Set DMA_SADDR_OOB[%#x]%#x\n", FMC_DMA_SADDR_OOB,
+			reg);
+
+#ifdef CONFIG_64BIT
+	reg = (host->dma_oob & FMC_DMA_SADDRH_MASK) >> 32;
+	hifmc_writel(host, FMC_DMA_SADDRH_OOB, reg);
+	FMC_PR(RD_DBG, "\t|-Set DMA_SADDRH_OOB[%#x]%#x\n", FMC_DMA_SADDRH_OOB,
+			reg);
+#endif
+#endif
+
+	reg = OP_CTRL_RD_OPCODE(spi->read->cmd) | host->cmd_op.op_cfg
+#ifdef HIFMC100_SPI_NAND_SUPPORT_REG_READ
+		| OP_CTRL_DMA_OP(OP_TYPE_REG)
+#else
+		| OP_CTRL_DMA_OP(OP_TYPE_DMA)
+#endif
+		| OP_CTRL_RW_OP(RW_OP_READ) | OP_CTRL_DMA_OP_READY;
+	hifmc_writel(host, FMC_OP_CTRL, reg);
+	FMC_PR(RD_DBG, "\t|-Set OP_CTRL[%#x]%#x\n", FMC_OP_CTRL, reg);
+
+	FMC_DMA_WAIT_INT_FINISH(host);
+
+	host->cache_addr_value[0] = host->addr_value[0];
+	host->cache_addr_value[1] = host->addr_value[1];
+
+end:
+	mutex_unlock(host->lock);
+	FMC_PR(RD_DBG, "\t*-End %s page read\n", op);
+}
+
+/*****************************************************************************/
+static void hifmc100_send_cmd_erase(struct hifmc_host *host)
+{
+	unsigned int reg;
+	struct hifmc_spi *spi = host->spi;
+
+	if (ER_DBG)
+		pr_info("\n");
+	FMC_PR(ER_DBG, "\t*-Start send cmd erase!\n");
+
+	mutex_lock(host->lock);
+	hifmc100_operation_config(host, OP_STYPE_ERASE);
+
+	reg = spi->driver->wait_ready(spi);
+	FMC_PR(ER_DBG, "\t|-Erase wait ready, reg: %#x\n", reg);
+	if (reg) {
+		DB_MSG("Error: Erase wait ready fail! status: %#x\n", reg);
+		goto end;
+	}
+
+	reg = spi->driver->write_enable(spi);
+	if (reg) {
+		DB_MSG("Error: Erase write enable failed! reg: %#x\n", reg);
+		goto end;
+	}
+
+	reg = FMC_INT_CLR_ALL;
+	hifmc_writel(host, FMC_INT_CLR, reg);
+	FMC_PR(ER_DBG, "\t|-Set INT_CLR[%#x]%#x\n", FMC_INT_CLR, reg);
+
+	reg = spi->erase->cmd;
+	hifmc_writel(host, FMC_CMD, FMC_CMD_CMD1(reg));
+	FMC_PR(ER_DBG, "\t|-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = FMC_ADDRL_BLOCK_H_MASK(host->addr_value[1])
+		| FMC_ADDRL_BLOCK_L_MASK(host->addr_value[0]);
+	hifmc_writel(host, FMC_ADDRL, reg);
+	FMC_PR(ER_DBG, "\t|-Set ADDRL[%#x]%#x\n", FMC_ADDRL, reg);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs)
+		| OP_CFG_MEM_IF_TYPE(spi->erase->iftype)
+		| OP_CFG_ADDR_NUM(STD_OP_ADDR_NUM)
+		| OP_CFG_DUMMY_NUM(spi->erase->dummy);
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(ER_DBG, "\t|-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = FMC_OP_CMD1_EN
+		| FMC_OP_ADDR_EN
+		| FMC_OP_REG_OP_START;
+	hifmc_writel(host, FMC_OP, reg);
+	FMC_PR(ER_DBG, "\t|-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	FMC_CMD_WAIT_CPU_FINISH(host);
+
+end:
+	mutex_unlock(host->lock);
+	FMC_PR(ER_DBG, "\t*-End send cmd erase!\n");
+}
+
+/*****************************************************************************/
+void hifmc100_ecc0_switch(struct hifmc_host *host, unsigned char op)
+{
+	unsigned int config;
+#if EC_DBG
+	unsigned int cmp_cfg;
+
+	config = hifmc_readl(host, FMC_CFG);
+	FMC_PR(EC_DBG, "\t *-Get CFG[%#x]%#x\n", FMC_CFG, config);
+
+	if (op)
+		cmp_cfg = host->fmc_cfg;
+	else
+		cmp_cfg = host->fmc_cfg_ecc0;
+
+	if (cmp_cfg != config)
+		DB_MSG("Warning: FMC config[%#x] is different.\n",
+				cmp_cfg);
+#endif
+
+	if (op == ENABLE)
+		config = host->fmc_cfg_ecc0;
+	else if (op == DISABLE)
+		config = host->fmc_cfg;
+	else {
+		DB_MSG("Error: Invalid opcode: %d\n", op);
+		return;
+	}
+
+	hifmc_writel(host, FMC_CFG, config);
+	FMC_PR(EC_DBG, "\t *-Set CFG[%#x]%#x\n", FMC_CFG, config);
+}
+
+/*****************************************************************************/
+static void hifmc100_send_cmd_readid(struct hifmc_host *host)
+{
+	unsigned int reg;
+
+	FMC_PR(BT_DBG, "\t|*-Start send cmd read ID\n");
+
+	hifmc100_ecc0_switch(host, ENABLE);
+
+	reg = FMC_CMD_CMD1(SPI_CMD_RDID);
+	hifmc_writel(host, FMC_CMD, reg);
+	FMC_PR(BT_DBG, "\t||-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = READ_ID_ADDR;
+	hifmc_writel(host, FMC_ADDRL, reg);
+	FMC_PR(BT_DBG, "\t||-Set ADDRL[%#x]%#x\n", FMC_ADDRL, reg);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs)
+		| OP_CFG_ADDR_NUM(READ_ID_ADDR_NUM);
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(BT_DBG, "\t||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = FMC_DATA_NUM_CNT(MAX_SPI_NAND_ID_LEN);
+	hifmc_writel(host, FMC_DATA_NUM, reg);
+	FMC_PR(BT_DBG, "\t||-Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, reg);
+
+	reg = FMC_OP_CMD1_EN
+		| FMC_OP_ADDR_EN
+		| FMC_OP_READ_DATA_EN
+		| FMC_OP_REG_OP_START;
+	hifmc_writel(host, FMC_OP, reg);
+	FMC_PR(BT_DBG, "\t||-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	host->addr_cycle = 0x0;
+
+	FMC_CMD_WAIT_CPU_FINISH(host);
+
+	hifmc100_ecc0_switch(host, DISABLE);
+
+	FMC_PR(BT_DBG, "\t|*-End read flash ID\n");
+}
+
+/*****************************************************************************/
+static void hifmc100_send_cmd_reset(struct hifmc_host *host)
+{
+	unsigned int reg;
+
+	FMC_PR(BT_DBG, "\t|*-Start send cmd reset\n");
+
+	reg = FMC_CMD_CMD1(SPI_CMD_RESET);
+	hifmc_writel(host, FMC_CMD, reg);
+	FMC_PR(BT_DBG, "\t||-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs);
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(BT_DBG, "\t||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = FMC_OP_CMD1_EN | FMC_OP_REG_OP_START;
+	hifmc_writel(host, FMC_OP, reg);
+	FMC_PR(BT_DBG, "\t||-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	FMC_CMD_WAIT_CPU_FINISH(host);
+
+	FMC_PR(BT_DBG, "\t|*-End send cmd reset\n");
+}
+
+/*****************************************************************************/
+static void hifmc100_host_init(struct hifmc_host *host)
+{
+	unsigned int reg;
+
+	FMC_PR(BT_DBG, "\t||*-Start SPI Nand host init\n");
+
+	reg = hifmc_readl(host, FMC_CFG);
+	if ((reg & FMC_CFG_OP_MODE_MASK) == FMC_CFG_OP_MODE_BOOT) {
+		reg |= FMC_CFG_OP_MODE(FMC_CFG_OP_MODE_NORMAL);
+		hifmc_writel(host, FMC_CFG, reg);
+		FMC_PR(BT_DBG, "\t|||-Set CFG[%#x]%#x\n", FMC_CFG, reg);
+	}
+
+	host->fmc_cfg = reg;
+	host->fmc_cfg_ecc0 = (reg & ~ECC_TYPE_MASK) | ECC_TYPE_0BIT;
+
+	reg = hifmc_readl(host, FMC_GLOBAL_CFG);
+	if (reg & FMC_GLOBAL_CFG_WP_ENABLE) {
+		reg &= ~FMC_GLOBAL_CFG_WP_ENABLE;
+		hifmc_writel(host, FMC_GLOBAL_CFG, reg);
+	}
+
+	host->addr_cycle = 0;
+	host->addr_value[0] = 0;
+	host->addr_value[1] = 0;
+	host->cache_addr_value[0] = ~0;
+	host->cache_addr_value[1] = ~0;
+
+	host->send_cmd_write = hifmc100_send_cmd_write;
+	host->send_cmd_status = hifmc100_send_cmd_status;
+	host->send_cmd_read = hifmc100_send_cmd_read;
+	host->send_cmd_erase = hifmc100_send_cmd_erase;
+	host->send_cmd_readid = hifmc100_send_cmd_readid;
+	host->send_cmd_reset = hifmc100_send_cmd_reset;
+#ifdef CONFIG_PM
+	host->suspend = hifmc100_suspend;
+	host->resume  = hifmc100_resume;
+#endif
+
+	reg = TIMING_CFG_TCSH(CS_HOLD_TIME)
+		| TIMING_CFG_TCSS(CS_SETUP_TIME)
+		| TIMING_CFG_TSHSL(CS_DESELECT_TIME);
+	hifmc_writel(host, FMC_SPI_TIMING_CFG, reg);
+
+	reg = ALL_BURST_ENABLE;
+	hifmc_writel(host, FMC_DMA_AHB_CTRL, reg);
+
+	FMC_PR(BT_DBG, "\t||*-End SPI Nand host init\n");
+}
+
+/*****************************************************************************/
+static unsigned char hifmc100_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+	unsigned char value, ret_val = 0;
+
+	if (host->cmd_op.l_cmd == NAND_CMD_READID) {
+		value = hifmc_readb(host->iobase + host->offset);
+		host->offset++;
+		if (host->cmd_op.data_no == host->offset)
+			host->cmd_op.l_cmd = 0;
+		return value;
+	}
+
+	if (host->cmd_op.cmd == NAND_CMD_STATUS) {
+		value = hifmc_readl(host, FMC_STATUS);
+		if (host->cmd_op.l_cmd == NAND_CMD_GET_FEATURES) {
+			FMC_PR((ER_DBG || WR_DBG), "\t\tRead BP status:%#x\n",
+					value);
+			if (ANY_BP_ENABLE(value))
+				ret_val |= NAND_STATUS_WP;
+
+			host->cmd_op.l_cmd = NAND_CMD_STATUS;
+		}
+
+		if (!(value & STATUS_OIP_MASK))
+			ret_val |= NAND_STATUS_READY;
+
+		if (value & STATUS_E_FAIL_MASK) {
+			FMC_PR(ER_DBG, "\t\tGet erase status: %#x\n", value);
+			ret_val |= NAND_STATUS_FAIL;
+		}
+
+		if (value & STATUS_P_FAIL_MASK) {
+			FMC_PR(WR_DBG, "\t\tGet write status: %#x\n", value);
+			ret_val |= NAND_STATUS_FAIL;
+		}
+
+		return ret_val;
+	}
+
+	if (host->cmd_op.l_cmd == NAND_CMD_READOOB) {
+		value  = hifmc_readb(host->buffer + host->pagesize + host->offset);
+		host->offset++;
+		return value;
+	}
+
+	host->offset++;
+
+	return hifmc_readb(host->buffer + host->column + host->offset - 1);
+}
+
+/*****************************************************************************/
+static unsigned short hifmc100_read_word(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+	host->offset += 2;
+	return hifmc_readw(host->buffer + host->column + host->offset - 2);
+}
+
+/*****************************************************************************/
+static void hifmc100_write_buf(struct mtd_info *mtd,
+	const u_char *buf, int len)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+#ifdef HIFMC100_SPI_NAND_SUPPORT_REG_WRITE
+	if (buf == chip->oob_poi)
+		memcpy((char *)host->iobase + host->pagesize, buf, len);
+	else
+		memcpy((char *)host->iobase, buf, len);
+#else
+	if (buf == chip->oob_poi)
+		memcpy((char *)(host->buffer + host->pagesize), buf, len);
+	else
+		memcpy((char *)host->buffer, buf, len);
+#endif
+	return;
+}
+
+/*****************************************************************************/
+static void hifmc100_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+#ifdef HIFMC100_SPI_NAND_SUPPORT_REG_READ
+	if (buf == chip->oob_poi)
+		memcpy(buf, (char *)host->iobase + host->pagesize, len);
+	else
+		memcpy(buf, (char *)host->iobase, len);
+#else
+	if (buf == chip->oob_poi)
+		memcpy(buf, (char *)host->buffer + host->pagesize, len);
+	else
+		memcpy(buf, (char *)host->buffer, len);
+#endif
+
+#ifdef CONFIG_HISI_NAND_ECC_STATUS_REPORT
+	if (buf != chip->oob_poi) {
+		u_int reg, ecc_step = host->pagesize >> 10;
+
+		reg = hifmc_readl(host, HIFMC100_ECC_ERR_NUM0_BUF0);
+		while (ecc_step) {
+			u_char err_num;
+
+			err_num = GET_ECC_ERR_NUM(--ecc_step, reg);
+			if (err_num == 0xff)
+				mtd->ecc_stats.failed++;
+			else
+				mtd->ecc_stats.corrected += err_num;
+		}
+	}
+#endif
+
+	return;
+}
+
+/*****************************************************************************/
+static void hifmc100_select_chip(struct mtd_info *mtd, int chipselect)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+	if (chipselect < 0)
+		return;
+
+	if (chipselect > CONFIG_SPI_NAND_MAX_CHIP_NUM)
+		DB_BUG("Error: Invalid chipselect: %d\n", chipselect);
+
+	if (host->mtd != mtd) {
+		host->mtd = mtd;
+		host->cmd_op.cs = chipselect;
+	}
+
+	if (!(chip->options & NAND_BROKEN_XD)) {
+		if ((chip->state == FL_ERASING) || (chip->state == FL_WRITING))
+			host->cmd_op.l_cmd = NAND_CMD_GET_FEATURES;
+	}
+}
+
+/*****************************************************************************/
+static void hifmc100_cmd_ctrl(struct mtd_info *mtd, int dat, unsigned ctrl)
+{
+	unsigned char cmd;
+	int is_cache_invalid = 1;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+	if (ctrl & NAND_ALE) {
+		unsigned int addr_value = 0;
+		unsigned int addr_offset = 0;
+
+		if (ctrl & NAND_CTRL_CHANGE) {
+			host->addr_cycle = 0x0;
+			host->addr_value[0] = 0x0;
+			host->addr_value[1] = 0x0;
+		}
+		addr_offset = host->addr_cycle << 3;
+
+		if (host->addr_cycle >= HIFMC100_ADDR_CYCLE_MASK) {
+			addr_offset = (host->addr_cycle -
+					HIFMC100_ADDR_CYCLE_MASK) << 3;
+			addr_value = 1;
+		}
+
+		host->addr_value[addr_value] |=
+			((dat & 0xff) << addr_offset);
+
+		host->addr_cycle++;
+	}
+
+	if ((ctrl & NAND_CLE) && (ctrl & NAND_CTRL_CHANGE)) {
+		cmd = dat & 0xff;
+		host->cmd_op.cmd = cmd;
+		switch (cmd) {
+		case NAND_CMD_PAGEPROG:
+			host->offset = 0;
+			host->send_cmd_write(host);
+			break;
+
+		case NAND_CMD_READSTART:
+			is_cache_invalid = 0;
+			if (host->addr_value[0] == host->pagesize)
+				host->cmd_op.l_cmd = NAND_CMD_READOOB;
+			host->send_cmd_read(host);
+			break;
+
+		case NAND_CMD_ERASE2:
+			host->send_cmd_erase(host);
+			break;
+
+		case NAND_CMD_READID:
+			memset((u_char *)(host->iobase), 0,
+					MAX_SPI_NAND_ID_LEN);
+			host->cmd_op.l_cmd = cmd;
+			host->cmd_op.data_no = MAX_SPI_NAND_ID_LEN;
+			host->send_cmd_readid(host);
+			break;
+
+		case NAND_CMD_STATUS:
+			host->send_cmd_status(host);
+			break;
+
+		case NAND_CMD_READ0:
+			host->cmd_op.l_cmd = cmd;
+			break;
+
+		case NAND_CMD_RESET:
+			host->send_cmd_reset(host);
+			break;
+
+		case NAND_CMD_SEQIN:
+		case NAND_CMD_ERASE1:
+		default:
+			break;
+		}
+	}
+
+	if ((dat == NAND_CMD_NONE) && host->addr_cycle) {
+		if (host->cmd_op.cmd == NAND_CMD_SEQIN
+			|| host->cmd_op.cmd == NAND_CMD_READ0
+			|| host->cmd_op.cmd == NAND_CMD_READID) {
+			host->offset = 0x0;
+			host->column = (host->addr_value[0] & 0xffff);
+		}
+	}
+
+	if (is_cache_invalid) {
+		host->cache_addr_value[0] = ~0;
+		host->cache_addr_value[1] = ~0;
+	}
+}
+
+/*****************************************************************************/
+static int hifmc100_dev_ready(struct mtd_info *mtd)
+{
+	unsigned int reg;
+	unsigned long deadline = jiffies + FMC_MAX_READY_WAIT_JIFFIES;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+	do {
+		reg = OP_CFG_FM_CS(host->cmd_op.cs);
+		hifmc_writel(host, FMC_OP_CFG, reg);
+
+		reg = FMC_OP_READ_STATUS_EN | FMC_OP_REG_OP_START;
+		hifmc_writel(host, FMC_OP, reg);
+
+		FMC_CMD_WAIT_CPU_FINISH(host);
+
+		reg = hifmc_readl(host, FMC_STATUS);
+
+		if (!(reg & STATUS_OIP_MASK))
+			return NAND_STATUS_READY;
+
+		cond_resched();
+
+	} while (!time_after_eq(jiffies, deadline));
+
+	if (!(chip->options & NAND_SCAN_SILENT_NODEV))
+		pr_warn("Wait SPI nand ready timeout, status: %#x\n", reg);
+
+	return 0;
+}
+
+/*****************************************************************************/
+/*
+ * 'host->epm' only use the first oobfree[0] field, it looks very simple, But...
+ */
+/* Default OOB area layout */
+static int hifmc_ooblayout_ecc_default(struct mtd_info *mtd, int section,
+		struct mtd_oob_region *oobregion)
+{
+	if (section)
+		return -ERANGE;
+
+	oobregion->length = 32;
+	oobregion->offset = 32;
+
+	return 0;
+}
+
+static int hifmc_ooblayout_free_default(struct mtd_info *mtd, int section,
+		struct mtd_oob_region *oobregion)
+{
+	if (section)
+		return -ERANGE;
+
+	oobregion->length = 30;
+	oobregion->offset = 2;
+
+	return 0;
+}
+
+static struct mtd_ooblayout_ops hifmc_ooblayout_default_ops = {
+	.ecc = hifmc_ooblayout_ecc_default,
+	.free = hifmc_ooblayout_free_default,
+};
+
+#ifdef CONFIG_HISI_NAND_FS_MAY_NO_YAFFS2
+static int hifmc_ooblayout_ecc_4k16bit(struct mtd_info *mtd, int section,
+		struct mtd_oob_region *oobregion)
+{
+	if (section)
+		return -ERANGE;
+
+	oobregion->length = 14;
+	oobregion->offset = 14;
+
+	return 0;
+}
+
+static int hifmc_ooblayout_free_4k16bit(struct mtd_info *mtd, int section,
+		struct mtd_oob_region *oobregion)
+{
+	if (section)
+		return -ERANGE;
+
+	oobregion->length = 14;
+	oobregion->offset = 2;
+
+	return 0;
+}
+
+static struct mtd_ooblayout_ops hifmc_ooblayout_4k16bit_ops = {
+	.ecc = hifmc_ooblayout_ecc_4k16bit,
+	.free = hifmc_ooblayout_free_4k16bit,
+};
+
+static int hifmc_ooblayout_ecc_2k16bit(struct mtd_info *mtd, int section,
+		struct mtd_oob_region *oobregion)
+{
+	if (section)
+		return -ERANGE;
+
+	oobregion->length = 6;
+	oobregion->offset = 6;
+
+	return 0;
+}
+
+static int hifmc_ooblayout_free_2k16bit(struct mtd_info *mtd, int section,
+		struct mtd_oob_region *oobregion)
+{
+	if (section)
+		return -ERANGE;
+
+	oobregion->length = 6;
+	oobregion->offset = 2;
+
+	return 0;
+}
+
+static struct mtd_ooblayout_ops hifmc_ooblayout_2k16bit_ops = {
+	.ecc = hifmc_ooblayout_ecc_2k16bit,
+	.free = hifmc_ooblayout_free_2k16bit,
+};
+#endif
+
+/*****************************************************************************/
+static struct nand_config_info hifmc_spi_nand_config_table[] = {
+	{NAND_PAGE_4K,	NAND_ECC_24BIT,	24, 200,	&hifmc_ooblayout_default_ops},
+#ifdef CONFIG_HISI_NAND_FS_MAY_NO_YAFFS2
+	{NAND_PAGE_4K,	NAND_ECC_16BIT,	16, 128,	&hifmc_ooblayout_4k16bit_ops},
+#endif
+	{NAND_PAGE_4K,	NAND_ECC_8BIT,	8, 88,		&hifmc_ooblayout_default_ops},
+	{NAND_PAGE_4K,	NAND_ECC_0BIT,	0, 32,		&hifmc_ooblayout_default_ops},
+
+	{NAND_PAGE_2K,	NAND_ECC_24BIT,	24, 128,	&hifmc_ooblayout_default_ops},
+#ifdef CONFIG_HISI_NAND_FS_MAY_NO_YAFFS2
+	{NAND_PAGE_2K,	NAND_ECC_16BIT,	16, 64,		&hifmc_ooblayout_2k16bit_ops},
+#endif
+	{NAND_PAGE_2K,	NAND_ECC_8BIT,	8, 64,		&hifmc_ooblayout_default_ops},
+	{NAND_PAGE_2K,	NAND_ECC_0BIT,	0, 32,		&hifmc_ooblayout_default_ops},
+
+	{0, 0, 0, 0, NULL},
+};
+
+/*
+ * Auto-sensed the page size and ecc type value. driver will try each of page
+ * size and ecc type one by one till flash can be read and wrote accurately.
+ * so the page size and ecc type is match adaptively without switch on the board
+ */
+static struct nand_config_info *hifmc100_get_config_type_info(
+		struct mtd_info *mtd, struct nand_dev_t *nand_dev)
+{
+	struct nand_config_info *best = NULL;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct nand_config_info *info = hifmc_spi_nand_config_table;
+
+	nand_dev->start_type = "Auto";
+
+	for (; info->ooblayout_ops; info++) {
+		if (match_page_type_to_size(info->pagetype) != mtd->writesize)
+			continue;
+
+		if (mtd->oobsize < info->oobsize)
+			continue;
+
+		if (!best || (best->ecctype < info->ecctype))
+			best = info;
+	}
+
+	/* All SPI NAND are small-page, SLC */
+	chip->bits_per_cell = 1;
+
+	return best;
+}
+
+/*****************************************************************************/
+static void hifmc100_chip_init(struct nand_chip *chip)
+{
+	chip->read_byte = hifmc100_read_byte;
+	chip->read_word = hifmc100_read_word;
+	chip->write_buf = hifmc100_write_buf;
+	chip->read_buf = hifmc100_read_buf;
+
+	chip->select_chip = hifmc100_select_chip;
+
+	chip->cmd_ctrl = hifmc100_cmd_ctrl;
+	chip->dev_ready = hifmc100_dev_ready;
+
+	chip->chip_delay = FMC_CHIP_DELAY;
+
+	chip->options = NAND_SKIP_BBTSCAN | NAND_BROKEN_XD
+		| NAND_SCAN_SILENT_NODEV;
+
+	chip->ecc.mode = NAND_ECC_NONE;
+}
+
+/*****************************************************************************/
+static void hifmc100_set_oob_info(struct mtd_info *mtd,
+		struct nand_config_info *info, struct nand_dev_t *nand_dev)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+	struct mtd_oob_region hifmc_oobregion = {0, 0};
+
+	if (info->ecctype != NAND_ECC_0BIT)
+		mtd->oobsize = info->oobsize;
+
+	host->oobsize = mtd->oobsize;
+	nand_dev->oobsize = host->oobsize;
+
+	host->dma_oob = host->dma_buffer + host->pagesize;
+	host->bbm = (u_char *)(host->buffer + host->pagesize
+			+ HIFMC_BAD_BLOCK_POS);
+
+	info->ooblayout_ops->free(mtd, 0, &hifmc_oobregion);
+
+	mtd_set_ooblayout(mtd, info->ooblayout_ops);
+
+	/* EB bits locate in the bottom two of CTRL(30) */
+	host->epm = (u_short *)(host->buffer + host->pagesize
+			+ hifmc_oobregion.offset + 28);
+
+#ifdef CONFIG_HISI_NAND_FS_MAY_NO_YAFFS2
+	if (best->ecctype == NAND_ECC_16BIT) {
+		if (host->pagesize == _2K) {
+			/* EB bits locate in the bottom two of CTRL(4) */
+			host->epm = (u_short *)(host->buffer + host->pagesize
+					+ hifmc_oobregion.offset + 4);
+		} else if (host->pagesize == _4K) {
+			/* EB bit locate in the bottom two of CTRL(14) */
+			host->epm = (u_short *)(host->buffer + host->pagesize
+					+ hifmc_oobregion.offset + 12);
+		}
+	}
+#endif
+}
+
+/*****************************************************************************/
+static unsigned int hifmc100_get_ecc_reg(struct hifmc_host *host,
+		struct nand_config_info *info, struct nand_dev_t *nand_dev)
+{
+	host->ecctype = info->ecctype;
+	nand_dev->ecctype = host->ecctype;
+
+	return FMC_CFG_ECC_TYPE(match_ecc_type_to_reg(info->ecctype));
+}
+
+/*****************************************************************************/
+static unsigned int hifmc100_get_page_reg(struct hifmc_host *host,
+		struct nand_config_info *info)
+{
+	host->pagesize = match_page_type_to_size(info->pagetype);
+
+	return FMC_CFG_PAGE_SIZE(match_page_type_to_reg(info->pagetype));
+}
+
+/*****************************************************************************/
+static unsigned int hifmc100_get_block_reg(struct hifmc_host *host,
+		struct nand_config_info *info)
+{
+	unsigned int block_reg = 0, page_per_block;
+	struct mtd_info *mtd = host->mtd;
+
+	host->block_page_mask = ((mtd->erasesize / mtd->writesize) - 1);
+	page_per_block = mtd->erasesize / match_page_type_to_size(info->pagetype);
+	switch (page_per_block) {
+		case 64:
+			block_reg = BLOCK_SIZE_64_PAGE;
+			break;
+		case 128:
+			block_reg = BLOCK_SIZE_128_PAGE;
+			break;
+		case 256:
+			block_reg = BLOCK_SIZE_256_PAGE;
+			break;
+		case 512:
+			block_reg = BLOCK_SIZE_512_PAGE;
+			break;
+		default:
+			DB_MSG("Can't support block %#x and page %#x size\n",
+					mtd->erasesize, mtd->writesize);
+	}
+
+	return FMC_CFG_BLOCK_SIZE(block_reg);
+}
+
+/*****************************************************************************/
+static void hifmc100_set_fmc_cfg_reg(struct hifmc_host *host,
+		struct nand_config_info *type_info, struct nand_dev_t *nand_dev)
+{
+	unsigned int page_reg, ecc_reg, block_reg, reg_fmc_cfg;
+
+	ecc_reg = hifmc100_get_ecc_reg(host, type_info, nand_dev);
+	page_reg = hifmc100_get_page_reg(host, type_info);
+	block_reg = hifmc100_get_block_reg(host, type_info);
+
+	reg_fmc_cfg = hifmc_readl(host, FMC_CFG);
+	reg_fmc_cfg &= ~(PAGE_SIZE_MASK | ECC_TYPE_MASK | BLOCK_SIZE_MASK);
+	reg_fmc_cfg |= ecc_reg | page_reg | block_reg;
+	hifmc_writel(host, FMC_CFG, reg_fmc_cfg);
+
+	/* Save value of FMC_CFG and FMC_CFG_ECC0 to turn on/off ECC */
+	host->fmc_cfg = reg_fmc_cfg;
+	host->fmc_cfg_ecc0 = (host->fmc_cfg & ~ECC_TYPE_MASK) | ECC_TYPE_0BIT;
+	FMC_PR(BT_DBG, "\t|-Save FMC_CFG[%#x]: %#x and FMC_CFG_ECC0: %#x\n",
+			FMC_CFG, host->fmc_cfg, host->fmc_cfg_ecc0);
+}
+
+/*****************************************************************************/
+static int hifmc100_set_config_info(struct mtd_info *mtd,
+		struct nand_chip *chip, struct nand_dev_t *nand_dev)
+{
+	struct hifmc_host *host = chip->priv;
+	struct nand_config_info *type_info = NULL;
+
+	FMC_PR(BT_DBG, "\t*-Start config Block Page OOB and Ecc\n");
+
+	type_info = hifmc100_get_config_type_info(mtd, nand_dev);
+	BUG_ON(!type_info);
+
+	FMC_PR(BT_DBG, "\t|-%s Config, PageSize %s EccType %s OOBSize %d\n",
+			nand_dev->start_type, nand_page_name(type_info->pagetype),
+			nand_ecc_name(type_info->ecctype), type_info->oobsize);
+
+	/* Set the page_size, ecc_type, block_size of FMC_CFG[0x0] register */
+	hifmc100_set_fmc_cfg_reg(host, type_info, nand_dev);
+
+	hifmc100_set_oob_info(mtd, type_info, nand_dev);
+
+	FMC_PR(BT_DBG, "\t*-End config Block Page Oob and Ecc\n");
+
+	return 0;
+}
+
+/*****************************************************************************/
+int hifmc100_spi_nand_init(struct nand_chip *chip)
+{
+	struct hifmc_host *host = chip->priv;
+
+	FMC_PR(BT_DBG, "\t|*-Start hifmc100 SPI Nand init\n");
+
+	/* Set system clock and enable controller */
+	clk_prepare_enable(host->clk);
+
+	/* Switch SPI type to SPI nand */
+	hifmc100_switch_to_spi_nand(host);
+
+	/* Hifmc host init */
+	hifmc100_host_init(host);
+	host->chip = chip;
+
+	/* Hifmc nand_chip struct init */
+	hifmc100_chip_init(chip);
+
+	hifmc_spi_nand_ids_register();
+	hinfc_param_adjust = hifmc100_set_config_info;
+
+	FMC_PR(BT_DBG, "\t|*-End hifmc100 SPI Nand init\n");
+
+	return 0;
+}
+#ifdef CONFIG_PM
+/*****************************************************************************/
+int hifmc100_suspend(struct platform_device *pltdev, pm_message_t state)
+{
+	unsigned int ret;
+	struct hifmc_host *host = platform_get_drvdata(pltdev);
+	struct hifmc_spi *spi = host->spi;
+
+	mutex_lock(host->lock);
+	hifmc100_switch_to_spi_nand(host);
+
+	ret = spi->driver->wait_ready(spi);
+	if (ret) {
+		DB_MSG("Error: wait ready failed!");
+		return 0;
+	}
+
+	clk_disable_unprepare(host->clk);
+	mutex_unlock(host->lock);
+
+	return 0;
+}
+/*****************************************************************************/
+int hifmc100_resume(struct platform_device *pltdev)
+{
+	int cs;
+	struct hifmc_host *host = platform_get_drvdata(pltdev);
+	struct nand_chip *chip = host->chip;
+
+	mutex_lock(host->lock);
+	hifmc100_switch_to_spi_nand(host);
+	clk_prepare_enable(host->clk);
+
+	for (cs = 0; cs < chip->numchips; cs++)
+		host->send_cmd_reset(host);
+
+	hifmc100_spi_nand_config(host);
+
+	mutex_unlock(host->lock);
+	return 0;
+}
+#endif
+
diff -ruN linux-4.9.37_original/drivers/mtd/nand/hifmc100/hifmc100.h linux-4.9.37_modified/drivers/mtd/nand/hifmc100/hifmc100.h
--- linux-4.9.37_original/drivers/mtd/nand/hifmc100/hifmc100.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/hifmc100/hifmc100.h	2018-07-04 07:50:03.075724383 +0300
@@ -0,0 +1,391 @@
+/*
+ * The Flash Memory Controller v100 Device Driver for hisilicon
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+ 
+#ifndef __HIFMC100_H__
+#define __HIFMC100_H__
+
+/*****************************************************************************/
+#include <linux/platform_device.h>
+#include <linux/mfd/hisi_fmc.h>
+
+/*****************************************************************************/
+#define INFINITE			(0xFFFFFFFF)
+
+/*****************************************************************************/
+#define SPI_IF_READ_STD			(0x01)
+#define SPI_IF_READ_FAST		(0x02)
+#define SPI_IF_READ_DUAL		(0x04)
+#define SPI_IF_READ_DUAL_ADDR		(0x08)
+#define SPI_IF_READ_QUAD		(0x10)
+#define SPI_IF_READ_QUAD_ADDR		(0x20)
+
+#define SPI_IF_WRITE_STD		(0x01)
+#define SPI_IF_WRITE_DUAL		(0x02)
+#define SPI_IF_WRITE_DUAL_ADDR		(0x04)
+#define SPI_IF_WRITE_QUAD		(0x08)
+#define SPI_IF_WRITE_QUAD_ADDR		(0x10)
+
+#define SPI_IF_ERASE_SECTOR_4K		(0x01)
+#define SPI_IF_ERASE_SECTOR_32K		(0x02)
+#define SPI_IF_ERASE_SECTOR_64K		(0x04)
+#define SPI_IF_ERASE_SECTOR_128K	(0x08)
+#define SPI_IF_ERASE_SECTOR_256K	(0x10)
+
+/******************************************************************************/
+#define HIFMC_SPI_NAND_SUPPORT_READ	(SPI_IF_READ_STD \
+					| SPI_IF_READ_FAST \
+					| SPI_IF_READ_DUAL \
+					| SPI_IF_READ_DUAL_ADDR \
+					| SPI_IF_READ_QUAD \
+					| SPI_IF_READ_QUAD_ADDR)
+
+#define HIFMC_SPI_NAND_SUPPORT_WRITE	(SPI_IF_WRITE_STD | SPI_IF_WRITE_QUAD)
+
+#define HIFMC_SPI_NAND_SUPPORT_MAX_DUMMY	8
+
+/*****************************************************************************/
+#define SPI_CMD_READ_STD		0x03	/* Standard read cache */
+#define SPI_CMD_READ_FAST		0x0B	/* Higher speed read cache */
+#define SPI_CMD_READ_DUAL		0x3B	/* 2 IO read cache only date */
+#define SPI_CMD_READ_DUAL_ADDR		0xBB	/* 2 IO read cache date&addr */
+#define SPI_CMD_READ_QUAD		0x6B	/* 4 IO read cache only date */
+#define SPI_CMD_READ_QUAD_ADDR		0xEB	/* 4 IO read cache date&addr */
+
+#define SPI_CMD_WRITE_STD		0x02	/* Standard page program */
+#define SPI_CMD_WRITE_DUAL		0xA2	/* 2 IO program only date */
+#define SPI_CMD_WRITE_DUAL_ADDR		0xD2	/* 2 IO program date&addr */
+#define SPI_CMD_WRITE_QUAD		0x32	/* 4 IO program only date */
+#define SPI_CMD_WRITE_QUAD_ADDR		0x12	/* 4 IO program date&addr */
+
+#define SPI_CMD_SE_4K			0x20	/* 4KB sector Erase */
+#define SPI_CMD_SE_32K			0x52	/* 32KB sector Erase */
+#define SPI_CMD_SE_64K			0xD8	/* 64KB sector Erase */
+#define SPI_CMD_SE_128K			0xD8	/* 128KB sector Erase */
+#define SPI_CMD_SE_256K			0xD8	/* 256KB sector Erase */
+
+/*****************************************************************************/
+#define SET_READ_STD(_dummy_, _size_, _clk_) \
+	static struct spi_op read_std_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_STD, SPI_CMD_READ_STD, _dummy_, _size_, _clk_ }
+
+#define SET_READ_FAST(_dummy_, _size_, _clk_) \
+	static struct spi_op read_fast_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_FAST, SPI_CMD_READ_FAST, _dummy_, _size_, _clk_ }
+
+#define SET_READ_DUAL(_dummy_, _size_, _clk_) \
+	static struct spi_op read_dual_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_DUAL, SPI_CMD_READ_DUAL, _dummy_, _size_, _clk_ }
+
+#define SET_READ_DUAL_ADDR(_dummy_, _size_, _clk_) \
+	static struct spi_op read_dual_addr_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_DUAL_ADDR, SPI_CMD_READ_DUAL_ADDR, _dummy_, _size_, _clk_ }
+
+#define SET_READ_QUAD(_dummy_, _size_, _clk_) \
+	static struct spi_op read_quad_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_QUAD, SPI_CMD_READ_QUAD, _dummy_, _size_, _clk_ }
+
+#define SET_READ_QUAD_ADDR(_dummy_, _size_, _clk_) \
+	static struct spi_op read_quad_addr_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_READ_QUAD_ADDR, SPI_CMD_READ_QUAD_ADDR, _dummy_, _size_, _clk_ }
+
+/*****************************************************************************/
+#define SET_WRITE_STD(_dummy_, _size_, _clk_) \
+	static struct spi_op write_std_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_WRITE_STD, SPI_CMD_WRITE_STD, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_DUAL(_dummy_, _size_, _clk_) \
+	static struct spi_op write_dual_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_WRITE_DUAL, SPI_CMD_WRITE_DUAL, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_DUAL_ADDR(_dummy_, _size_, _clk_) \
+	static struct spi_op write_dual_addr_##_dummy_##_size_##_clk_ = { \
+SPI_IF_WRITE_DUAL_ADDR, SPI_CMD_WRITE_DUAL_ADDR, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_QUAD(_dummy_, _size_, _clk_) \
+	static struct spi_op write_quad_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_WRITE_QUAD, SPI_CMD_WRITE_QUAD, _dummy_, _size_, _clk_ }
+
+#define SET_WRITE_QUAD_ADDR(_dummy_, _size_, _clk_) \
+	static struct spi_op write_quad_addr_##_dummy_##_size_##_clk_ = { \
+SPI_IF_WRITE_QUAD_ADDR, SPI_CMD_WRITE_QUAD_ADDR, _dummy_, _size_, _clk_ }
+
+/*****************************************************************************/
+#define SET_ERASE_SECTOR_4K(_dummy_, _size_, _clk_) \
+	static struct spi_op erase_sector_4k_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_ERASE_SECTOR_4K, SPI_CMD_SE_4K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_32K(_dummy_, _size_, _clk_) \
+	static struct spi_op erase_sector_32k_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_ERASE_SECTOR_32K, SPI_CMD_SE_32K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_64K(_dummy_, _size_, _clk_) \
+	static struct spi_op erase_sector_64k_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_ERASE_SECTOR_64K, SPI_CMD_SE_64K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_128K(_dummy_, _size_, _clk_) \
+	static struct spi_op erase_sector_128k_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_ERASE_SECTOR_128K, SPI_CMD_SE_128K, _dummy_, _size_, _clk_ }
+
+#define SET_ERASE_SECTOR_256K(_dummy_, _size_, _clk_) \
+	static struct spi_op erase_sector_256k_##_dummy_##_size_##_clk_ = { \
+	SPI_IF_ERASE_SECTOR_256K, SPI_CMD_SE_256K, _dummy_, _size_, _clk_ }
+
+/*****************************************************************************/
+#define READ_STD(_dummy_, _size_, _clk_) read_std_##_dummy_##_size_##_clk_
+#define READ_FAST(_dummy_, _size_, _clk_) read_fast_##_dummy_##_size_##_clk_
+#define READ_DUAL(_dummy_, _size_, _clk_) read_dual_##_dummy_##_size_##_clk_
+#define READ_DUAL_ADDR(_dummy_, _size_, _clk_) \
+		read_dual_addr_##_dummy_##_size_##_clk_
+#define READ_QUAD(_dummy_, _size_, _clk_) read_quad_##_dummy_##_size_##_clk_
+#define READ_QUAD_ADDR(_dummy_, _size_, _clk_) \
+		read_quad_addr_##_dummy_##_size_##_clk_
+
+/*****************************************************************************/
+#define WRITE_STD(_dummy_, _size_, _clk_) write_std_##_dummy_##_size_##_clk_
+#define WRITE_DUAL(_dummy_, _size_, _clk_) write_dual_##_dummy_##_size_##_clk_
+#define WRITE_DUAL_ADDR(_dummy_, _size_, _clk_) \
+		write_dual_addr_##_dummy_##_size_##_clk_
+#define WRITE_QUAD(_dummy_, _size_, _clk_) write_quad_##_dummy_##_size_##_clk_
+#define WRITE_QUAD_ADDR(_dummy_, _size_, _clk_) \
+		write_quad_addr_##_dummy_##_size_##_clk_
+
+/*****************************************************************************/
+#define ERASE_SECTOR_4K(_dummy_, _size_, _clk_) \
+		erase_sector_4k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_32K(_dummy_, _size_, _clk_) \
+		erase_sector_32k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_64K(_dummy_, _size_, _clk_) \
+		erase_sector_64k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_128K(_dummy_, _size_, _clk_) \
+		erase_sector_128k_##_dummy_##_size_##_clk_
+#define ERASE_SECTOR_256K(_dummy_, _size_, _clk_) \
+		erase_sector_256k_##_dummy_##_size_##_clk_
+
+/*****************************************************************************/
+#define SPI_CMD_WREN			0x06	/* Write Enable */
+#define SPI_CMD_WRDI			0x04	/* Write Disable */
+
+#define SPI_CMD_RDID			0x9F	/* Read Identification */
+
+/*****************************************************************************/
+#define SPI_CMD_GET_FEATURES		0x0F	/* Get Features */
+#define SPI_CMD_SET_FEATURE		0x1F	/* Set Feature */
+
+#define SPI_CMD_PAGE_READ		0x13	/* Page Read to Cache */
+
+#define SPI_CMD_RESET			0xff	/* Reset the device */
+
+/*****************************************************************************/
+/* These macroes are for debug only, reg option is slower then dma option */
+#undef HIFMC100_SPI_NAND_SUPPORT_REG_READ
+/* #define HIFMC100_SPI_NAND_SUPPORT_REG_READ */
+
+#undef HIFMC100_SPI_NAND_SUPPORT_REG_WRITE
+/* #define HIFMC100_SPI_NAND_SUPPORT_REG_WRITE */
+
+#ifdef CONFIG_HISI_NAND_ECC_STATUS_REPORT
+/*****************************************************************************/
+#define HIFMC100_ECC_ERR_NUM0_BUF0		0xc0
+
+#define GET_ECC_ERR_NUM(_i, _reg)		(((_reg) >> ((_i) * 8)) & 0xff)
+#endif
+/*****************************************************************************/
+#define REG_CNT_HIGH_BLOCK_NUM_SHIFT		10
+
+#define REG_CNT_BLOCK_NUM_MASK			0x3ff
+#define REG_CNT_BLOCK_NUM_SHIFT			22
+
+#define REG_CNT_PAGE_NUM_MASK			0x3f
+#define REG_CNT_PAGE_NUM_SHIFT			16
+
+#define REG_CNT_WRAP_MASK			0xf
+#define REG_CNT_WRAP_SHIFT			12
+
+#define REG_CNT_ECC_OFFSET_MASK			0xfff
+#define REG_CNT_ECC_8BIT_OFFSET			1054
+#define REG_CNT_ECC_16BIT_OFFSET		1056
+#define REG_CNT_ECC_24BIT_OFFSET		1082
+
+#define ERR_STR_DRIVER "Driver does not support this configure "
+#define ERR_STR_CHECK "Please make sure the hardware configuration is correct"
+
+/*****************************************************************************/
+#define HIFMC100_ADDR_CYCLE_MASK		0x2
+
+/*****************************************************************************/
+#define OP_STYPE_NONE			0x0
+#define OP_STYPE_READ			0x01
+#define OP_STYPE_WRITE			0x02
+#define OP_STYPE_ERASE			0x04
+#define CLK_FMC_TO_CRG_MHZ(_clk)	((_clk) * 2000000)
+
+/*****************************************************************************/
+#define MAX_SPI_OP			8
+
+/*****************************************************************************/
+/* SPI general operation parameter */
+struct spi_op {
+	unsigned char iftype;
+	unsigned char cmd;
+	unsigned char dummy;
+	unsigned int size;
+	unsigned int clock;
+};
+
+struct spi_drv;
+
+/* SPI interface all operation */
+struct hifmc_spi {
+	char *name;
+	int chipselect;
+	unsigned long long chipsize;
+	unsigned int erasesize;
+#define SPI_NOR_3BYTE_ADDR_LEN	3	/* address len 3Bytes */
+#define SPI_NOR_4BYTE_ADDR_LEN	4	/* address len 4Bytes for 32MB */
+	unsigned int addrcycle;
+
+	struct spi_op read[1];
+	struct spi_op write[1];
+	struct spi_op erase[MAX_SPI_OP];
+
+	void *host;
+
+	struct spi_drv *driver;
+};
+
+/* SPI interface special operation function hook */
+struct spi_drv {
+	int (*wait_ready)(struct hifmc_spi *spi);
+	int (*write_enable)(struct hifmc_spi *spi);
+	int (*qe_enable)(struct hifmc_spi *spi);
+	int (*bus_prepare)(struct hifmc_spi *spi, int op);
+	int (*entry_4addr)(struct hifmc_spi *spi, int en);
+};
+
+struct spi_nand_info {
+	char *name;
+	unsigned char id[MAX_SPI_NAND_ID_LEN];
+	unsigned char id_len;
+	unsigned long long chipsize;
+	unsigned int erasesize;
+	unsigned int pagesize;
+	unsigned int oobsize;
+#define BBP_LAST_PAGE		0x01
+#define BBP_FIRST_PAGE		0x02
+	unsigned int badblock_pos;
+	struct spi_op *read[MAX_SPI_OP];
+	struct spi_op *write[MAX_SPI_OP];
+	struct spi_op *erase[MAX_SPI_OP];
+	struct spi_drv *driver;
+};
+
+/*****************************************************************************/
+extern u_char spi_nand_feature_op(struct hifmc_spi *spi, u_char op, u_char addr,
+		u_char val);
+
+/*****************************************************************************/
+struct hifmc_host {
+	struct mtd_info *mtd;
+	struct nand_chip *chip;
+	struct hifmc_spi spi[CONFIG_SPI_NAND_MAX_CHIP_NUM];
+	struct hifmc_cmd_op cmd_op;
+
+	void __iomem *iobase;
+	void __iomem *regbase;
+	struct clk *clk;
+	u32 clkrate;
+
+	unsigned int fmc_cfg;
+	unsigned int fmc_cfg_ecc0;
+
+	unsigned int offset;
+
+	struct device *dev;
+	struct mutex *lock;
+
+	/* This is maybe an un-aligment address, only for malloc or free */
+	char *buforg;
+	char *buffer;
+
+#ifdef CONFIG_64BIT
+	unsigned long long dma_buffer;
+	unsigned long long dma_oob;
+#else
+	unsigned int dma_buffer;
+	unsigned int dma_oob;
+#endif
+
+	unsigned int addr_cycle;
+	unsigned int addr_value[2];
+	unsigned int cache_addr_value[2];
+
+	unsigned int column;
+	unsigned int block_page_mask;
+
+	unsigned int ecctype;
+	unsigned int pagesize;
+	unsigned int oobsize;
+
+	int add_partition;
+
+	int  need_rr_data;
+#define HIFMC100_READ_RETRY_DATA_LEN         128
+	char rr_data[HIFMC100_READ_RETRY_DATA_LEN];
+	struct read_retry_t *read_retry;
+
+	int version;
+
+	/* BOOTROM read two bytes to detect the bad block flag */
+#define HIFMC_BAD_BLOCK_POS		0
+	unsigned char *bbm;	/* nand bad block mark */
+	unsigned short *epm;	/* nand empty page mark */
+
+	unsigned int uc_er;
+
+	void (*send_cmd_write)(struct hifmc_host *host);
+	void (*send_cmd_status)(struct hifmc_host *host);
+	void (*send_cmd_read)(struct hifmc_host *host);
+	void (*send_cmd_erase)(struct hifmc_host *host);
+	void (*send_cmd_readid)(struct hifmc_host *host);
+	void (*send_cmd_reset)(struct hifmc_host *host);
+#ifdef CONFIG_PM
+	int (*suspend)(struct platform_device *pltdev, pm_message_t state);
+	int (*resume)(struct platform_device *pltdev);
+#endif
+};
+
+/*****************************************************************************/
+void hifmc100_ecc0_switch(struct hifmc_host *host, unsigned char op);
+
+int hifmc100_spi_nand_init(struct nand_chip *chip);
+
+/*****************************************************************************/
+extern void hifmc_spi_nand_ids_register(void);
+
+extern void hifmc_set_nand_system_clock(struct spi_op *op, int clk_en);
+
+/*****************************************************************************/
+#ifdef CONFIG_PM
+int hifmc100_suspend(struct platform_device *pltdev, pm_message_t state);
+int hifmc100_resume(struct platform_device *pltdev);
+void hifmc100_spi_nand_config(struct hifmc_host *host);
+#endif
+
+#endif /* End of __HIFMC100_H__ */
diff -ruN linux-4.9.37_original/drivers/mtd/nand/hifmc100/hifmc100_os.c linux-4.9.37_modified/drivers/mtd/nand/hifmc100/hifmc100_os.c
--- linux-4.9.37_original/drivers/mtd/nand/hifmc100/hifmc100_os.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/hifmc100/hifmc100_os.c	2018-07-04 07:50:03.075724383 +0300
@@ -0,0 +1,237 @@
+/*
+ * The Flash Memory Controller v100 Device Driver for hisilicon
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/of_platform.h>
+#include <linux/mfd/hisi_fmc.h>
+
+#include <asm/setup.h>
+
+#include "../../mtdcore.h"
+#include "hifmc100.h"
+#include "hifmc100_os.h"
+
+/*****************************************************************************/
+static int hifmc100_spi_nand_pre_probe(struct nand_chip *chip)
+{
+	uint8_t nand_maf_id;
+	struct hifmc_host *host = chip->priv;
+
+	/* Reset the chip first */
+	host->send_cmd_reset(host);
+	udelay(1000);
+
+	/* Check the ID */
+	host->offset = 0;
+	memset((unsigned char *)(chip->IO_ADDR_R), 0, 0x10);
+	host->send_cmd_readid(host);
+	nand_maf_id = hifmc_readb(chip->IO_ADDR_R);
+
+	if (nand_maf_id == 0x00 || nand_maf_id == 0xff) {
+		printk("Cannot found a valid SPI Nand Device\n");
+		return 1;
+	}
+
+	return 0;
+}
+/*****************************************************************************/
+static int hifmc_nand_scan(struct mtd_info *mtd)
+{
+	int result = 0;
+	unsigned char cs, chip_num = CONFIG_SPI_NAND_MAX_CHIP_NUM;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+
+	for (cs = 0; chip_num && (cs < HIFMC_MAX_CHIP_NUM); cs++) {
+		if (hifmc_cs_user[cs]) {
+			FMC_PR(BT_DBG, "\t\t*-Current CS(%d) is occupied.\n",
+					cs);
+			continue;
+		}
+
+		host->cmd_op.cs = cs;
+
+		if (hifmc100_spi_nand_pre_probe(chip))
+			return -ENODEV;
+
+		FMC_PR(BT_DBG, "\t\t*-Scan SPI nand flash on CS: %d\n", cs);
+		if (nand_scan(mtd, chip_num))
+			continue;
+		chip_num--;
+	}
+
+	if (chip_num == CONFIG_SPI_NAND_MAX_CHIP_NUM)
+		result = -ENXIO;
+	else
+		result = 0;
+
+	return result;
+}
+
+/*****************************************************************************/
+static int hisi_spi_nand_probe(struct platform_device *pltdev)
+{
+	int len, result = 0;
+	struct hifmc_host *host;
+	struct nand_chip *chip;
+	struct mtd_info *mtd;
+	struct device *dev = &pltdev->dev;
+	struct device_node *np = NULL;
+	struct hisi_fmc *fmc = dev_get_drvdata(dev->parent);
+
+	FMC_PR(BT_DBG, "\t*-Start SPI Nand flash driver probe\n");
+
+	len = sizeof(struct hifmc_host) + sizeof(struct nand_chip)
+		+ sizeof(struct mtd_info);
+	host = devm_kzalloc(dev, len, GFP_KERNEL);
+	if (!host)
+		return -ENOMEM;
+	memset((char *)host, 0, len);
+
+	platform_set_drvdata(pltdev, host);
+	host->dev = &pltdev->dev;
+
+	host->chip = chip = (struct nand_chip *)&host[1];
+	host->mtd  = mtd  = nand_to_mtd(chip);
+
+	host->regbase = fmc->regbase;
+	host->iobase = fmc->iobase;
+	host->clk = fmc->clk;
+	host->lock = &fmc->lock;
+
+	memset((char *)host->iobase, 0xff, SPI_NAND_BUFFER_LEN);
+	chip->IO_ADDR_R = chip->IO_ADDR_W = host->iobase;
+
+	host->buffer = dmam_alloc_coherent(host->dev, SPI_NAND_BUFFER_LEN,
+			&host->dma_buffer, GFP_KERNEL);
+	if (!host->buffer) {
+		DB_MSG("Error: Can't allocate memory for dma buffer.");
+		result = -EIO;
+		goto fail;
+	}
+	memset(host->buffer, 0xff, SPI_NAND_BUFFER_LEN);
+
+	chip->priv = host;
+	result = hifmc100_spi_nand_init(chip);
+	if (result) {
+		FMC_PR(BT_DBG, "\t|-SPI Nand init failed, ret: %d\n", result);
+		result = -ENODEV;
+		goto fail;
+	}
+
+	np = of_get_next_available_child(dev->of_node, NULL);
+	mtd->name = np->name;
+	mtd->type = MTD_NANDFLASH;
+	mtd->priv = chip;
+	mtd->owner = THIS_MODULE;
+
+	result = of_property_read_u32(np, "spi-max-frequency", &host->clkrate);
+	if (result)
+		goto fail;
+
+	result = hifmc_nand_scan(mtd);
+	if (result) {
+		FMC_PR(BT_DBG, "\t|-Scan SPI Nand failed.\n");
+		goto fail;
+	}
+
+	result = mtd_device_register(mtd, NULL, 0);
+	if (!result) {
+		FMC_PR(BT_DBG, "\t*-End driver probe !!\n");
+	    return 0;
+	}
+
+	result = -ENODEV;
+fail:
+	clk_disable_unprepare(host->clk);
+	nand_release(mtd);
+
+	DB_MSG("Error: driver probe, result: %d\n", result);
+	return result;
+}
+
+/*****************************************************************************/
+static int hisi_spi_nand_remove(struct platform_device *pltdev)
+{
+	struct hifmc_host *host = platform_get_drvdata(pltdev);
+
+	dmam_free_coherent(host->dev, SPI_NAND_BUFFER_LEN,
+			host->buffer, host->dma_buffer);
+	clk_disable_unprepare(host->clk);
+	nand_release(host->mtd);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/*****************************************************************************/
+static int hifmc100_os_suspend(struct platform_device *pltdev,
+		pm_message_t state)
+{
+	struct hifmc_host *host = platform_get_drvdata(pltdev);
+
+	if (host && host->suspend)
+		return (host->suspend)(pltdev, state);
+
+	return 0;
+}
+
+/*****************************************************************************/
+static int hifmc100_os_resume(struct platform_device *pltdev)
+{
+	struct hifmc_host *host = platform_get_drvdata(pltdev);
+
+	if (host && host->resume)
+		return (host->resume)(pltdev);
+
+	return 0;
+}
+#endif /* End of CONFIG_PM */
+/*****************************************************************************/
+static const struct of_device_id hisi_spi_nand_dt_ids[] = {
+	{ .compatible = "hisilicon,hisi-spi-nand"},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, hisi_spi_nand_dt_ids);
+
+static struct platform_driver hisi_spi_nand_driver = {
+	.driver = {
+		.name	= "hisi_spi_nand",
+		.of_match_table = hisi_spi_nand_dt_ids,
+	},
+	.probe	= hisi_spi_nand_probe,
+	.remove = hisi_spi_nand_remove,
+#ifdef CONFIG_PM
+	.suspend	= hifmc100_os_suspend,
+	.resume		= hifmc100_os_resume,
+#endif
+};
+module_platform_driver(hisi_spi_nand_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("BVT_BSP");
+MODULE_DESCRIPTION("Hisilicon Flash Memory Controller V100 SPI Nand Driver");
diff -ruN linux-4.9.37_original/drivers/mtd/nand/hifmc100/hifmc100_os.h linux-4.9.37_modified/drivers/mtd/nand/hifmc100/hifmc100_os.h
--- linux-4.9.37_original/drivers/mtd/nand/hifmc100/hifmc100_os.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/hifmc100/hifmc100_os.h	2018-07-04 07:50:03.075724383 +0300
@@ -0,0 +1,30 @@
+/*
+ * The Flash Memory Controller v100 Device Driver for hisilicon
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __HIFMC100_OS_H__
+#define __HIFMC100_OS_H__
+
+/*****************************************************************************/
+#define SPI_NAND_MAX_PAGESIZE			4096
+#define SPI_NAND_MAX_OOBSIZE			256
+
+#define SPI_NAND_BUFFER_LEN	(SPI_NAND_MAX_PAGESIZE + SPI_NAND_MAX_OOBSIZE)
+
+#endif /* End of __HIFMC100_OS_H__ */
diff -ruN linux-4.9.37_original/drivers/mtd/nand/hifmc100/hifmc100_spi_general.c linux-4.9.37_modified/drivers/mtd/nand/hifmc100/hifmc100_spi_general.c
--- linux-4.9.37_original/drivers/mtd/nand/hifmc100/hifmc100_spi_general.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/hifmc100/hifmc100_spi_general.c	2018-07-04 07:50:03.075724383 +0300
@@ -0,0 +1,253 @@
+/*
+ * The Flash Memory Controller v100 Device Driver for hisilicon
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/*
+	Send set/get features command to SPI Nand flash
+*/
+u_char spi_nand_feature_op(struct hifmc_spi *spi, u_char op, u_char addr,
+		u_char val)
+{
+	unsigned int reg;
+	const char *str[] = {"Get", "Set"};
+	struct hifmc_host *host = (struct hifmc_host *)spi->host;
+
+	if ((GET_OP == op) && (STATUS_ADDR == addr)) {
+		if (SR_DBG)
+			pr_info("\n");
+		FMC_PR(SR_DBG, "\t\t|*-Start Get Status\n");
+
+		reg = OP_CFG_FM_CS(host->cmd_op.cs);
+		hifmc_writel(host, FMC_OP_CFG, reg);
+		FMC_PR(SR_DBG, "\t\t||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+		reg = FMC_OP_READ_STATUS_EN | FMC_OP_REG_OP_START;
+		hifmc_writel(host, FMC_OP, reg);
+		FMC_PR(SR_DBG, "\t\t||-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+		FMC_CMD_WAIT_CPU_FINISH(host);
+
+		val = hifmc_readl(host, FMC_STATUS);
+		FMC_PR(SR_DBG, "\t\t|*-End Get Status, result: %#x\n", val);
+
+		return val;
+	}
+
+	FMC_PR(FT_DBG, "\t|||*-Start %s feature, addr[%#x]\n", str[op], addr);
+
+	hifmc100_ecc0_switch(host, ENABLE);
+
+	reg = FMC_CMD_CMD1(op ? SPI_CMD_SET_FEATURE : SPI_CMD_GET_FEATURES);
+	hifmc_writel(host, FMC_CMD, reg);
+	FMC_PR(FT_DBG, "\t||||-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	hifmc_writel(host, FMC_ADDRL, addr);
+	FMC_PR(FT_DBG, "\t||||-Set ADDRL[%#x]%#x\n", FMC_ADDRL, addr);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs)
+		| OP_CFG_ADDR_NUM(FEATURES_OP_ADDR_NUM);
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(FT_DBG, "\t||||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = FMC_DATA_NUM_CNT(FEATURES_DATA_LEN);
+	hifmc_writel(host, FMC_DATA_NUM, reg);
+	FMC_PR(FT_DBG, "\t||||-Set DATA_NUM[%#x]%#x\n", FMC_DATA_NUM, reg);
+
+	reg = FMC_OP_CMD1_EN
+		| FMC_OP_ADDR_EN
+		| FMC_OP_REG_OP_START;
+
+	if (SET_OP == op) {
+		reg |= FMC_OP_WRITE_DATA_EN;
+		hifmc_writeb(val, host->iobase);
+		FMC_PR(FT_DBG, "\t||||-Write IO[%#lx]%#x\n", (long)host->iobase,
+				*(u_char *)host->iobase);
+	} else
+		reg |= FMC_OP_READ_DATA_EN;
+
+	hifmc_writel(host, FMC_OP, reg);
+	FMC_PR(FT_DBG, "\t||||-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	FMC_CMD_WAIT_CPU_FINISH(host);
+
+	if (GET_OP == op) {
+		val = hifmc_readb(host->iobase);
+		FMC_PR(FT_DBG, "\t||||-Read IO[%#lx]%#x\n", (long)host->iobase,
+				*(u_char *)host->iobase);
+	}
+
+	hifmc100_ecc0_switch(host, DISABLE);
+
+	FMC_PR(FT_DBG, "\t|||*-End %s Feature[%#x]:%#x\n", str[op], addr, val);
+
+	return val;
+}
+
+/*****************************************************************************/
+/*
+	Read status[C0H]:[0]bit OIP, judge whether the device is busy or not
+*/
+static int spi_general_wait_ready(struct hifmc_spi *spi)
+{
+	unsigned char status;
+	unsigned long deadline = jiffies + FMC_MAX_READY_WAIT_JIFFIES;
+	struct hifmc_host *host = (struct hifmc_host *)spi->host;
+
+	do {
+		status = spi_nand_feature_op(spi, GET_OP, STATUS_ADDR, 0);
+		if (!(status & STATUS_OIP_MASK)) {
+			if ((host->cmd_op.l_cmd == NAND_CMD_ERASE2)
+			    && (status & STATUS_E_FAIL_MASK))
+				return status;
+			if ((host->cmd_op.l_cmd == NAND_CMD_PAGEPROG)
+			    && (status & STATUS_P_FAIL_MASK))
+				return status;
+			return 0;
+		}
+
+		cond_resched();
+
+	} while (!time_after_eq(jiffies, deadline));
+
+	DB_MSG("Error: SPI Nand wait ready timeout, status: %#x\n", status);
+
+	return 1;
+}
+
+/*****************************************************************************/
+/*
+	Send write enable cmd to SPI Nand, status[C0H]:[2]bit WEL must be set 1
+*/
+static int spi_general_write_enable(struct hifmc_spi *spi)
+{
+	unsigned int reg;
+	struct hifmc_host *host = (struct hifmc_host *)spi->host;
+
+	if (WE_DBG)
+		pr_info("\n");
+	FMC_PR(WE_DBG, "\t|*-Start Write Enable\n");
+
+	reg = spi_nand_feature_op(spi, GET_OP, STATUS_ADDR, 0);
+	if (reg & STATUS_WEL_MASK) {
+		FMC_PR(WE_DBG, "\t||-Write Enable was opened! reg: %#x\n",
+				reg);
+		return 0;
+	}
+
+	reg = hifmc_readl(host, FMC_GLOBAL_CFG);
+	FMC_PR(WE_DBG, "\t||-Get GLOBAL_CFG[%#x]%#x\n", FMC_GLOBAL_CFG, reg);
+	if (reg & FMC_GLOBAL_CFG_WP_ENABLE) {
+		reg &= ~FMC_GLOBAL_CFG_WP_ENABLE;
+		hifmc_writel(host, FMC_GLOBAL_CFG, reg);
+		FMC_PR(WE_DBG, "\t||-Set GLOBAL_CFG[%#x]%#x\n",
+				FMC_GLOBAL_CFG, reg);
+	}
+
+	reg = FMC_CMD_CMD1(SPI_CMD_WREN);
+	hifmc_writel(host, FMC_CMD, reg);
+	FMC_PR(WE_DBG, "\t||-Set CMD[%#x]%#x\n", FMC_CMD, reg);
+
+	reg = OP_CFG_FM_CS(host->cmd_op.cs);
+	hifmc_writel(host, FMC_OP_CFG, reg);
+	FMC_PR(WE_DBG, "\t||-Set OP_CFG[%#x]%#x\n", FMC_OP_CFG, reg);
+
+	reg = FMC_OP_CMD1_EN | FMC_OP_REG_OP_START;
+	hifmc_writel(host, FMC_OP, reg);
+	FMC_PR(WE_DBG, "\t||-Set OP[%#x]%#x\n", FMC_OP, reg);
+
+	FMC_CMD_WAIT_CPU_FINISH(host);
+
+#if WE_DBG
+	spi->driver->wait_ready(spi);
+
+	reg = spi_nand_feature_op(spi, GET_OP, STATUS_ADDR, 0);
+	if (reg & STATUS_WEL_MASK)
+		FMC_PR(WE_DBG, "\t||-Write Enable success. reg: %#x\n", reg);
+	else {
+		DB_MSG("Error: Write Enable failed! reg: %#x\n", reg);
+		return reg;
+	}
+#endif
+
+	FMC_PR(WE_DBG, "\t|*-End Write Enable\n");
+	return 0;
+}
+
+/*****************************************************************************/
+/*
+	judge whether SPI Nand support QUAD read/write or not
+*/
+static int spi_is_quad(struct hifmc_spi *spi)
+{
+	const char *if_str[] = {"STD", "DUAL", "DIO", "QUAD", "QIO"};
+
+	FMC_PR(QE_DBG, "\t\t|||*-SPI read iftype: %s write iftype: %s\n",
+		if_str[spi->read->iftype], if_str[spi->write->iftype]);
+
+	if ((IF_TYPE_QUAD == spi->read->iftype)
+	    || (IF_TYPE_QIO == spi->read->iftype)
+	    || (IF_TYPE_QUAD == spi->write->iftype)
+	    || (IF_TYPE_QIO == spi->write->iftype))
+		return 1;
+
+	return 0;
+}
+
+/*****************************************************************************/
+/*
+	Send set features cmd to SPI Nand, feature[B0H]:[0]bit QE would be set
+*/
+static int spi_general_qe_enable(struct hifmc_spi *spi)
+{
+	unsigned int reg, op;
+	const char *str[] = {"Disable", "Enable"};
+
+	FMC_PR(QE_DBG, "\t||*-Start SPI Nand flash QE\n");
+
+	op = spi_is_quad(spi);
+
+	FMC_PR(QE_DBG, "\t|||*-End Quad check, SPI Nand %s Quad.\n", str[op]);
+
+	reg = spi_nand_feature_op(spi, GET_OP, FEATURE_ADDR, 0);
+	FMC_PR(QE_DBG, "\t|||-Get [%#x]feature: %#x\n", FEATURE_ADDR, reg);
+	if ((reg & FEATURE_QE_ENABLE) == op) {
+		FMC_PR(QE_DBG, "\t||*-SPI Nand quad was %sd!\n", str[op]);
+		return op;
+	}
+
+	if (op == ENABLE)
+		reg |= FEATURE_QE_ENABLE;
+	else
+		reg &= ~FEATURE_QE_ENABLE;
+
+	spi_nand_feature_op(spi, SET_OP, FEATURE_ADDR, reg);
+	FMC_PR(QE_DBG, "\t|||-SPI Nand %s Quad\n", str[op]);
+
+	spi->driver->wait_ready(spi);
+
+	reg = spi_nand_feature_op(spi, GET_OP, FEATURE_ADDR, 0);
+	if ((reg & FEATURE_QE_ENABLE) == op)
+		FMC_PR(QE_DBG, "\t|||-SPI Nand %s Quad succeed!\n", str[op]);
+	else
+		DB_MSG("Error: %s Quad failed! reg: %#x\n", str[op], reg);
+
+	FMC_PR(QE_DBG, "\t||*-End SPI Nand %s Quad.\n", str[op]);
+
+	return op;
+}
diff -ruN linux-4.9.37_original/drivers/mtd/nand/hifmc100/hifmc_spi_nand_ids.c linux-4.9.37_modified/drivers/mtd/nand/hifmc100/hifmc_spi_nand_ids.c
--- linux-4.9.37_original/drivers/mtd/nand/hifmc100/hifmc_spi_nand_ids.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/hifmc100/hifmc_spi_nand_ids.c	2018-07-04 07:50:03.079724422 +0300
@@ -0,0 +1,1341 @@
+/*
+ * The Flash Memory Controller v100 Device Driver for hisilicon
+ *
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+ 
+#include <asm/setup.h>
+#include <linux/types.h>
+#include <linux/io.h>
+#include <linux/sched.h>
+#include <linux/printk.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <mach/platform.h>
+#include <linux/mfd/hisi_fmc.h>
+
+#include "../hinfc_gen.h"
+#include "hifmc100.h"
+
+/*****************************************************************************/
+SET_READ_STD(1, INFINITE, 24);
+
+SET_READ_FAST(1, INFINITE, 75);
+SET_READ_FAST(1, INFINITE, 80);
+SET_READ_FAST(1, INFINITE, 104);
+SET_READ_FAST(1, INFINITE, 108);
+SET_READ_FAST(1, INFINITE, 120);
+
+SET_READ_DUAL(1, INFINITE, 75);
+SET_READ_DUAL(1, INFINITE, 80);
+SET_READ_DUAL(1, INFINITE, 104);
+SET_READ_DUAL(1, INFINITE, 108);
+SET_READ_DUAL(1, INFINITE, 120);
+
+SET_READ_DUAL_ADDR(1, INFINITE, 75);
+SET_READ_DUAL_ADDR(1, INFINITE, 80);
+SET_READ_DUAL_ADDR(1, INFINITE, 104);
+SET_READ_DUAL_ADDR(1, INFINITE, 108);
+SET_READ_DUAL_ADDR(1, INFINITE, 120);
+
+SET_READ_QUAD(1, INFINITE, 75);
+SET_READ_QUAD(1, INFINITE, 80);
+SET_READ_QUAD(1, INFINITE, 104);
+SET_READ_QUAD(1, INFINITE, 108);
+SET_READ_QUAD(1, INFINITE, 120);
+
+SET_READ_QUAD_ADDR(1, INFINITE, 75);
+SET_READ_QUAD_ADDR(2, INFINITE, 75);
+SET_READ_QUAD_ADDR(1, INFINITE, 80);
+SET_READ_QUAD_ADDR(2, INFINITE, 80);
+SET_READ_QUAD_ADDR(2, INFINITE, 104);
+SET_READ_QUAD_ADDR(1, INFINITE, 108);
+SET_READ_QUAD_ADDR(1, INFINITE, 120);
+
+/*****************************************************************************/
+SET_WRITE_STD(0, 256, 24);
+SET_WRITE_STD(0, 256, 75);
+SET_WRITE_STD(0, 256, 80);
+SET_WRITE_STD(0, 256, 104);
+
+SET_WRITE_QUAD(0, 256, 75);
+SET_WRITE_QUAD(0, 256, 80);
+SET_WRITE_QUAD(0, 256, 104);
+SET_WRITE_QUAD(0, 256, 108);
+SET_WRITE_QUAD(0, 256, 120);
+
+/*****************************************************************************/
+SET_ERASE_SECTOR_128K(0, _128K, 24);
+SET_ERASE_SECTOR_128K(0, _128K, 75);
+SET_ERASE_SECTOR_128K(0, _128K, 80);
+SET_ERASE_SECTOR_128K(0, _128K, 104);
+
+SET_ERASE_SECTOR_256K(0, _256K, 24);
+SET_ERASE_SECTOR_256K(0, _256K, 75);
+SET_ERASE_SECTOR_256K(0, _256K, 80);
+SET_ERASE_SECTOR_256K(0, _256K, 104);
+
+/*****************************************************************************/
+#include "hifmc100_spi_general.c"
+static struct spi_drv spi_driver_general = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.qe_enable = spi_general_qe_enable,
+};
+
+/* some spi nand flash default QUAD enable, needn't to set qe enable */
+static struct spi_drv spi_driver_no_qe = {
+	.wait_ready = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+};
+
+/*****************************************************************************/
+#define SPI_NAND_ID_TAB_VER		"2.4"
+
+/******* SPI Nand ID Table ***************************************************
+* Version	Manufacturer	Chip Name	Size		Operation
+* 1.0		ESMT		F50L512M41A	64MB		Add 5 chip
+*		GD		5F1GQ4UAYIG	128MB
+*		GD		5F2GQ4UAYIG	256MB
+*		GD		5F4GQ4UAYIG	512MB
+*		GD		5F4GQ4UBYIG	512MB
+* 1.1		ESMT		F50L1G41A	128MB		Add 2 chip
+*		Winbond		W25N01GV	128MB
+* 1.2		GD		5F1GQ4UBYIG	128MB		Add 2 chip
+*		GD		5F2GQ4UBYIG	256MB
+* 1.3		ATO		ATO25D1GA	128MB		Add 1 chip
+* 1.4		MXIC		MX35LF1GE4AB	128MB		Add 2 chip
+*		MXIC		MX35LF2GE4AB	256MB		(SOP-16Pin)
+* 1.5		Paragon		PN26G01A	128MB		Add 1 chip
+* 1.6		All-flash	AFS1GQ4UAC	128MB		Add 1 chip
+* 1.7		TOSHIBA		TC58CVG0S3H	128MB		Add 2 chip
+*		TOSHIBA		TC58CVG2S0H	512MB
+* 1.8		ALL-flash	AFS2GQ4UAD	256MB		Add 2 chip
+*		Paragon		PN26G02A	256MB
+* 1.9		TOSHIBA		TC58CVG1S3H	256MB		Add 1 chip
+* 2.0		HeYangTek	HYF1GQ4UAACAE	128MB		Add 3 chip
+*		HeYangTek	HYF2GQ4UAACAE	256MB
+*		HeYangTek	HYF4GQ4UAACBE	512MB
+* 2.1		Micron		MT29F1G01ABA	128MB		Add 5 chip
+		Paragon	1.8V	PN26Q01AWSIUG	128MB
+		TOSHIBA 1.8V	TC58CYG0S3H	128MB
+		TOSHIBA 1.8V	TC58CYG1S3H	256MB
+		TOSHIBA 1.8V	TC58CYG2S0H	512MB
+* 2.2		Micron		MT29F2G01ABA	256MB		Add 1 chip
+* 2.3		MXIC		MX35LF2G14AC	256MB		Add 1 chip
+* 2.4	    GD 1.8V		5F4GQ4RAYIG		512MB		Add 1 chip
+******************************************************************************/
+struct spi_nand_info hifmc_spi_nand_flash_table[] = {
+	/* Micron MT29F1G01ABA 1GBit */
+	{
+		.name      = "MT29F1G01ABA",
+		.id        = {0x2C, 0x14},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_DUAL_ADDR(1, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			&READ_QUAD_ADDR(2, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 80),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* Micron MT29F2G01ABA 2GBit */
+	{
+		.name      = "MT29F2G01ABA",
+		.id        = {0x2C, 0x24},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 108),
+			&READ_DUAL(1, INFINITE, 108),
+			&READ_DUAL_ADDR(1, INFINITE, 108),
+			&READ_QUAD(1, INFINITE, 108),
+			&READ_QUAD_ADDR(2, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 108),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 80),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* ESMT F50L512M41A 512Mbit */
+	{
+		.name      = "F50L512M41A",
+		.id        = {0xC8, 0x20},
+		.id_len    = 2,
+		.chipsize  = _64M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* ESMT F50L1G41A 1Gbit */
+	{
+		.name      = "F50L1G41A",
+		.id        = {0xC8, 0x21},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* GD 5F1GQ4UAYIG 1Gbit */
+	{
+		.name      = "5F1GQ4UAYIG",
+		.id        = {0xc8, 0xf1},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 5F1GQ4UBYIG 1Gbit */
+	{
+		.name      = "5F1GQ4UBYIG",
+		.id        = {0xc8, 0xd1},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 5F2GQ4UAYIG 2Gbit */
+	{
+		.name      = "5F2GQ4UAYIG",
+		.id        = {0xc8, 0xf2},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 5F2GQ4UBYIG 2Gbit */
+	{
+		.name      = "5F2GQ4UBYIG",
+		.id        = {0xc8, 0xd2},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 5F4GQ4UAYIG 4Gbit */
+	{
+		.name      = "5F4GQ4UAYIG",
+		.id        = {0xc8, 0xf4},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 5F4GQ4UBYIG 4Gbit */
+	{
+		.name      = "5F4GQ4UBYIG",
+		.id        = {0xc8, 0xd4},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 120),
+			&READ_DUAL(1, INFINITE, 120),
+			&READ_DUAL_ADDR(1, INFINITE, 120),
+			&READ_QUAD(1, INFINITE, 120),
+			&READ_QUAD_ADDR(1, INFINITE, 120),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 120),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* GD 1.8V 5F4GQ4RAYIG 4Gbit */
+	{
+		.name      = "5F4GQ4RAYIG",
+		.id        = {0xc8, 0xe4},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 75),
+			&READ_DUAL(1, INFINITE, 75),
+			&READ_DUAL_ADDR(1, INFINITE, 75),
+			&READ_QUAD(1, INFINITE, 75),
+			&READ_QUAD_ADDR(1, INFINITE, 75),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 75),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Winbond W25N01GV 1Gbit */
+	{
+		.name      = "W25N01GV",
+		.id        = {0xef, 0xaa, 0x21},
+		.id_len    = 3,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_DUAL_ADDR(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			&READ_QUAD_ADDR(2, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* Winbond W25N01GW 1Gbit 1.8V */
+	{
+		.name      = "W25N01GW",
+		.id        = {0xef, 0xba, 0x21},
+		.id_len    = 3,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 75),
+			&READ_DUAL(1, INFINITE, 75),
+			&READ_DUAL_ADDR(1, INFINITE, 75),
+			&READ_QUAD(1, INFINITE, 75),
+			&READ_QUAD_ADDR(2, INFINITE, 75),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 75),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* ATO ATO25D1GA 1Gbit */
+	{
+		.name      = "ATO25D1GA",
+		.id        = {0x9b, 0x12},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* MXIC MX35LF1GE4AB 1Gbit */
+	{
+		.name      = "MX35LF1GE4AB",
+		.id        = {0xc2, 0x12},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* MXIC MX35LF2GE4AB 2Gbit SOP-16Pin */
+	{
+		.name      = "MX35LF2GE4AB",
+		.id        = {0xc2, 0x22},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* MXIC MX35LF2G14AC 2GBit */
+	{
+		.name      = "MX35LF2G14AC",
+		.id        = {0xc2, 0x20},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Paragon PN26G01AWSIUG 1Gbit 1.8V */
+	{
+		.name      = "PN26G01AW",
+		.id        = {0xa1, 0xc1},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 75),
+			&READ_DUAL(1, INFINITE, 75),
+			&READ_DUAL_ADDR(1, INFINITE, 75),
+			&READ_QUAD(1, INFINITE, 75),
+			&READ_QUAD_ADDR(1, INFINITE, 75),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 75),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 75),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Paragon PN26G01A 1Gbit */
+	{
+		.name      = "PN26G01A",
+		.id        = {0xa1, 0xe1},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 108),
+			&READ_DUAL(1, INFINITE, 108),
+			&READ_DUAL_ADDR(1, INFINITE, 108),
+			&READ_QUAD(1, INFINITE, 108),
+			&READ_QUAD_ADDR(1, INFINITE, 108),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 108),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* Paragon PN26G02A 2Gbit */
+	{
+		.name      = "PN26G02A",
+		.id        = {0xa1, 0xe2},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 108),
+			&READ_DUAL(1, INFINITE, 108),
+			&READ_DUAL_ADDR(1, INFINITE, 108),
+			&READ_QUAD(1, INFINITE, 108),
+			&READ_QUAD_ADDR(1, INFINITE, 108),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 108),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* All-flash AFS1GQ4UAC 1Gbit */
+	{
+		.name      = "AFS1GQ4UAC",
+		.id        = {0xc1, 0x51},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_DUAL_ADDR(1, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			&READ_QUAD_ADDR(1, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* All-flash AFS2GQ4UAD 2Gbit */
+	{
+		.name      = "AFS2GQ4UAD",
+		.id        = {0xc1, 0x52},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_DUAL_ADDR(1, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			&READ_QUAD_ADDR(1, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 24),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 24),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* TOSHIBA TC58CVG0S3H 1Gbit */
+	{
+		.name      = "TC58CVG0S3H",
+		.id        = {0x98, 0xc2},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CYG0S3H 1.8V 1Gbit */
+	{
+		.name      = "TC58CYG0S3H",
+		.id        = {0x98, 0xb2},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 75),
+			&READ_DUAL(1, INFINITE, 75),
+			&READ_QUAD(1, INFINITE, 75),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 75),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 75),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CVG1S3H 2Gbit */
+	{
+		.name      = "TC58CVG1S3H",
+		.id        = {0x98, 0xcb},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 64,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 104),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CYG1S3H 1.8V 2Gbit */
+	{
+		.name      = "TC58CYG1S3H",
+		.id        = {0x98, 0xbb},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 75),
+			&READ_DUAL(1, INFINITE, 75),
+			&READ_QUAD(1, INFINITE, 75),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 75),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 75),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CVG2S0H 4Gbit */
+	{
+		.name      = "TC58CVG2S0H",
+		.id        = {0x98, 0xcd},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 104),
+			&READ_DUAL(1, INFINITE, 104),
+			&READ_QUAD(1, INFINITE, 104),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 104),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 104),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* TOSHIBA TC58CYG2S0H 1.8V 4Gbit */
+	{
+		.name      = "TC58CYG2S0H",
+		.id        = {0x98, 0xbd},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 75),
+			&READ_DUAL(1, INFINITE, 75),
+			&READ_QUAD(1, INFINITE, 75),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 75),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 75),
+			0
+		},
+		.driver    = &spi_driver_no_qe,
+	},
+
+	/* HeYangTek HYF1GQ4UAACAE 1Gbit */
+	{
+		.name      = "HYF1GQ4UAACAE",
+		.id        = {0xc9, 0x51},
+		.id_len    = 2,
+		.chipsize  = _128M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_DUAL_ADDR(1, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			&READ_QUAD_ADDR(1, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 80),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* HeYangTek HYF2GQ4UAACAE 2Gbit */
+	{
+		.name      = "HYF2GQ4UAACAE",
+		.id        = {0xc9, 0x52},
+		.id_len    = 2,
+		.chipsize  = _256M,
+		.erasesize = _128K,
+		.pagesize  = _2K,
+		.oobsize   = 128,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_DUAL_ADDR(1, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			&READ_QUAD_ADDR(1, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_128K(0, _128K, 80),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	/* HeYangTek HYF4GQ4UAACBE 4Gbit */
+	{
+		.name      = "HYF4GQ4UAACBE",
+		.id        = {0xc9, 0xd4},
+		.id_len    = 2,
+		.chipsize  = _512M,
+		.erasesize = _256K,
+		.pagesize  = _4K,
+		.oobsize   = 256,
+		.badblock_pos = BBP_FIRST_PAGE,
+		.read      = {
+			&READ_STD(1, INFINITE, 24),
+			&READ_FAST(1, INFINITE, 80),
+			&READ_DUAL(1, INFINITE, 80),
+			&READ_DUAL_ADDR(1, INFINITE, 80),
+			&READ_QUAD(1, INFINITE, 80),
+			&READ_QUAD_ADDR(1, INFINITE, 80),
+			0
+		},
+		.write     = {
+			&WRITE_STD(0, 256, 80),
+			&WRITE_QUAD(0, 256, 80),
+			0
+		},
+		.erase     = {
+			&ERASE_SECTOR_256K(0, _256K, 80),
+			0
+		},
+		.driver    = &spi_driver_general,
+	},
+
+	{	.id_len    = 0,	},
+};
+
+/*****************************************************************************/
+static void hifmc100_spi_nand_search_rw(struct spi_nand_info *spiinfo,
+	struct spi_op *spiop_rw, u_int iftype, u_int max_dummy, int rw_type)
+{
+	int ix = 0;
+	struct spi_op **spiop, **fitspiop;
+
+	for (fitspiop = spiop = (rw_type ? spiinfo->write : spiinfo->read);
+		(*spiop) && ix < MAX_SPI_OP; spiop++, ix++) {
+		if (((*spiop)->iftype & iftype)
+			&& ((*spiop)->dummy <= max_dummy)
+			&& (*fitspiop)->iftype < (*spiop)->iftype)
+			fitspiop = spiop;
+	}
+	memcpy(spiop_rw, (*fitspiop), sizeof(struct spi_op));
+}
+
+/*****************************************************************************/
+static void hifmc100_spi_nand_get_erase(struct spi_nand_info *spiinfo,
+		struct spi_op *spiop_erase)
+{
+	int ix;
+
+	spiop_erase->size = 0;
+	for (ix = 0; ix < MAX_SPI_OP; ix++) {
+		if (spiinfo->erase[ix] == NULL)
+			break;
+		if (spiinfo->erasesize == spiinfo->erase[ix]->size) {
+			memcpy(&spiop_erase[ix], spiinfo->erase[ix],
+					sizeof(struct spi_op));
+			break;
+		}
+	}
+}
+
+/*****************************************************************************/
+static void hifmc100_map_spi_op(struct hifmc_spi *spi)
+{
+	unsigned char ix;
+	const int iftype_read[] = {
+		SPI_IF_READ_STD,	IF_TYPE_STD,
+		SPI_IF_READ_FAST,	IF_TYPE_STD,
+		SPI_IF_READ_DUAL,	IF_TYPE_DUAL,
+		SPI_IF_READ_DUAL_ADDR,	IF_TYPE_DIO,
+		SPI_IF_READ_QUAD,	IF_TYPE_QUAD,
+		SPI_IF_READ_QUAD_ADDR,	IF_TYPE_QIO,
+		0,			0,
+	};
+	const int iftype_write[] = {
+		SPI_IF_WRITE_STD,	IF_TYPE_STD,
+		SPI_IF_WRITE_QUAD,	IF_TYPE_QUAD,
+		0,			0,
+	};
+	const char *if_str[] = {"STD", "DUAL", "DIO", "QUAD", "QIO"};
+
+	FMC_PR(BT_DBG, "\t||*-Start Get SPI operation iftype\n");
+
+	for (ix = 0; iftype_write[ix]; ix += 2) {
+		if (spi->write->iftype == iftype_write[ix]) {
+			spi->write->iftype = iftype_write[ix + 1];
+			break;
+		}
+	}
+	FMC_PR(BT_DBG, "\t|||-Get best write iftype: %s \n",
+		if_str[spi->write->iftype]);
+
+	for (ix = 0; iftype_read[ix]; ix += 2) {
+		if (spi->read->iftype == iftype_read[ix]) {
+			spi->read->iftype = iftype_read[ix + 1];
+			break;
+		}
+	}
+	FMC_PR(BT_DBG, "\t|||-Get best read iftype: %s \n",
+		if_str[spi->read->iftype]);
+
+	spi->erase->iftype = IF_TYPE_STD;
+	FMC_PR(BT_DBG, "\t|||-Get best erase iftype: %s \n",
+		if_str[spi->erase->iftype]);
+
+	FMC_PR(BT_DBG, "\t||*-End Get SPI operation iftype \n");
+}
+
+/*****************************************************************************/
+static void hifmc100_spi_ids_probe(struct mtd_info *mtd,
+				struct spi_nand_info *spi_dev)
+{
+	unsigned int reg;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+	struct hifmc_spi *spi = host->spi;
+
+	FMC_PR(BT_DBG, "\t|*-Start match SPI operation & chip init\n");
+
+	spi->host = host;
+	spi->name = spi_dev->name;
+	spi->driver = spi_dev->driver;
+
+	hifmc100_spi_nand_search_rw(spi_dev, spi->read,
+			HIFMC_SPI_NAND_SUPPORT_READ,
+			HIFMC_SPI_NAND_SUPPORT_MAX_DUMMY, RW_OP_READ);
+	FMC_PR(BT_DBG, "\t||-Save spi->read op cmd:%#x\n", spi->read->cmd);
+
+	hifmc100_spi_nand_search_rw(spi_dev, spi->write,
+			HIFMC_SPI_NAND_SUPPORT_WRITE,
+			HIFMC_SPI_NAND_SUPPORT_MAX_DUMMY, RW_OP_WRITE);
+	FMC_PR(BT_DBG, "\t||-Save spi->write op cmd:%#x\n", spi->write->cmd);
+
+	hifmc100_spi_nand_get_erase(spi_dev, spi->erase);
+	FMC_PR(BT_DBG, "\t||-Save spi->erase op cmd:%#x\n", spi->erase->cmd);
+
+	hifmc100_map_spi_op(spi);
+
+	if (spi->driver->qe_enable)
+		spi->driver->qe_enable(spi);
+
+	/* Disable write protection */
+	reg = spi_nand_feature_op(spi, GET_OP, PROTECT_ADDR, 0);
+	FMC_PR(BT_DBG, "\t||-Get protect status[%#x]: %#x\n", PROTECT_ADDR,
+			reg);
+	if (ANY_BP_ENABLE(reg)) {
+		reg &= ~ALL_BP_MASK;
+		spi_nand_feature_op(spi, SET_OP, PROTECT_ADDR, reg);
+		FMC_PR(BT_DBG, "\t||-Set [%#x]FT %#x\n", PROTECT_ADDR, reg);
+
+		spi->driver->wait_ready(spi);
+
+		reg = spi_nand_feature_op(spi, GET_OP, PROTECT_ADDR, 0);
+		FMC_PR(BT_DBG, "\t||-Check BP disable result: %#x\n", reg);
+		if (ANY_BP_ENABLE(reg))
+			DB_MSG("Error: Write protection disable failed!\n");
+	}
+
+	/* Disable chip internal ECC */
+	reg = spi_nand_feature_op(spi, GET_OP, FEATURE_ADDR, 0);
+	FMC_PR(BT_DBG, "\t||-Get feature status[%#x]: %#x\n", FEATURE_ADDR,
+			reg);
+	if (reg & FEATURE_ECC_ENABLE) {
+		reg &= ~FEATURE_ECC_ENABLE;
+		spi_nand_feature_op(spi, SET_OP, FEATURE_ADDR, reg);
+		FMC_PR(BT_DBG, "\t||-Set [%#x]FT: %#x\n", FEATURE_ADDR, reg);
+
+		spi->driver->wait_ready(spi);
+
+		reg = spi_nand_feature_op(spi, GET_OP, FEATURE_ADDR, 0);
+		FMC_PR(BT_DBG, "\t||-Check internal ECC disable result: %#x\n",
+				reg);
+		if (reg & FEATURE_ECC_ENABLE)
+			DB_MSG("Error: Chip internal ECC disable failed!\n");
+	}
+
+	hifmc_cs_user[host->cmd_op.cs]++;
+
+	FMC_PR(BT_DBG, "\t|*-End match SPI operation & chip init\n");
+}
+
+static struct nand_flash_dev spi_nand_dev;
+/*****************************************************************************/
+static struct nand_flash_dev *spi_nand_get_flash_info(struct mtd_info *mtd,
+		unsigned char *id)
+{
+	unsigned char ix, len = 0;
+	char buffer[100];
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct hifmc_host *host = chip->priv;
+	struct spi_nand_info *spi_dev = hifmc_spi_nand_flash_table;
+	struct nand_flash_dev *type = &spi_nand_dev;
+
+	FMC_PR(BT_DBG, "\t*-Start find SPI Nand flash\n");
+
+	len = sprintf(buffer, "SPI Nand(cs %d) ID: %#x %#x",
+			host->cmd_op.cs, id[0], id[1]);
+
+	for (; spi_dev->id_len; spi_dev++) {
+		if (memcmp(id, spi_dev->id, spi_dev->id_len))
+			continue;
+
+		for (ix = 2; ix < spi_dev->id_len; ix++)
+			len += sprintf(buffer + len, " %#x", id[ix]);
+		pr_info("%s\n", buffer);
+
+		FMC_PR(BT_DBG, "\t||-CS(%d) found SPI Nand: %s\n",
+				host->cmd_op.cs, spi_dev->name);
+
+		type->name = spi_dev->name;
+		memcpy(type->id, spi_dev->id, spi_dev->id_len);
+		type->pagesize = spi_dev->pagesize;
+		type->chipsize = spi_dev->chipsize >> 20;
+		type->erasesize = spi_dev->erasesize;
+		type->id_len = spi_dev->id_len;
+		type->oobsize = spi_dev->oobsize;
+		FMC_PR(BT_DBG, "\t|-Save struct nand_flash_dev info\n");
+
+		mtd->oobsize = spi_dev->oobsize;
+		mtd->erasesize = spi_dev->erasesize;
+		mtd->writesize = spi_dev->pagesize;
+		chip->chipsize = spi_dev->chipsize;
+
+		hifmc100_spi_ids_probe(mtd, spi_dev);
+
+		FMC_PR(BT_DBG, "\t*-Found SPI nand: %s\n", spi_dev->name);
+
+		return type;
+	}
+
+	FMC_PR(BT_DBG, "\t*-Not found SPI nand flash, %s\n", buffer);
+
+	return NULL;
+}
+
+/*****************************************************************************/
+void hifmc_spi_nand_ids_register(void)
+{
+	pr_info("SPI Nand ID Table Version %s\n", SPI_NAND_ID_TAB_VER);
+	get_spi_nand_flash_type_hook = spi_nand_get_flash_info;
+}
+
+#ifdef CONFIG_PM
+/*****************************************************************************/
+void hifmc100_spi_nand_config(struct hifmc_host *host)
+{
+	unsigned int reg;
+	struct hifmc_spi *spi = host->spi;
+	static const char const *str[] = {"STD", "DUAL", "DIO", "QUAD", "QIO"};
+
+	/* judge whether support QUAD read/write or not, set it if yes */
+	FMC_PR(PM_DBG, "\t|-SPI read iftype: %s write iftype: %s\n",
+		str[spi->read->iftype], str[spi->write->iftype]);
+
+	if (spi->driver->qe_enable)
+		spi->driver->qe_enable(spi);
+
+	/* Disable write protection */
+	reg = spi_nand_feature_op(spi, GET_OP, PROTECT_ADDR, 0);
+	FMC_PR(PM_DBG, "\t|-Get protect status[%#x]: %#x\n", PROTECT_ADDR,
+			reg);
+	if (ANY_BP_ENABLE(reg)) {
+		reg &= ~ALL_BP_MASK;
+		spi_nand_feature_op(spi, SET_OP, PROTECT_ADDR, reg);
+		FMC_PR(PM_DBG, "\t|-Set [%#x]FT %#x\n", PROTECT_ADDR, reg);
+
+		spi->driver->wait_ready(spi);
+
+		reg = spi_nand_feature_op(spi, GET_OP, PROTECT_ADDR, 0);
+		FMC_PR(PM_DBG, "\t|-Check BP disable result: %#x\n", reg);
+		if (ANY_BP_ENABLE(reg))
+			DB_MSG("Error: Write protection disable failed!\n");
+	}
+
+	/* Disable chip internal ECC */
+	reg = spi_nand_feature_op(spi, GET_OP, FEATURE_ADDR, 0);
+	FMC_PR(PM_DBG, "\t|-Get feature status[%#x]: %#x\n", FEATURE_ADDR,
+			reg);
+	if (reg & FEATURE_ECC_ENABLE) {
+		reg &= ~FEATURE_ECC_ENABLE;
+		spi_nand_feature_op(spi, SET_OP, FEATURE_ADDR, reg);
+		FMC_PR(PM_DBG, "\t|-Set [%#x]FT: %#x\n", FEATURE_ADDR, reg);
+
+		spi->driver->wait_ready(spi);
+
+		reg = spi_nand_feature_op(spi, GET_OP, FEATURE_ADDR, 0);
+		FMC_PR(PM_DBG, "\t|-Check internal ECC disable result: %#x\n",
+				reg);
+		if (reg & FEATURE_ECC_ENABLE)
+			DB_MSG("Error: Chip internal ECC disable failed!\n");
+	}
+}
+/*****************************************************************************/
+#endif /* CONFIG_PM */
diff -ruN linux-4.9.37_original/drivers/mtd/nand/hifmc100/Kconfig linux-4.9.37_modified/drivers/mtd/nand/hifmc100/Kconfig
--- linux-4.9.37_original/drivers/mtd/nand/hifmc100/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/hifmc100/Kconfig	2018-07-04 07:50:03.075724383 +0300
@@ -0,0 +1,17 @@
+#
+# hisilicon flash memory controller SPI nand device driver version 100
+# drivers/mtd/nand/hifmc100/Kconfig
+# add by hisilicon 2017.8.7
+#
+
+config MTD_SPI_NAND_HIFMC100
+	bool "Hisilicon Flash Memory Controller v100 SPI Nand devices support"
+	depends on MFD_HISI_FMC && MTD_SPI_NAND_HISI_BVT
+	select MISC_FILESYSTEMS
+	select MTD_BLOCK
+	select YAFFS_FS
+	select YAFFS_YAFFS2
+	help
+	  Hisilicon Flash Memory Controller version 100 is called hifmc100 for
+	  short. The controller driver support registers and DMA transfers
+	  while reading or writing the SPI nand flash.
diff -ruN linux-4.9.37_original/drivers/mtd/nand/hifmc100/Makefile linux-4.9.37_modified/drivers/mtd/nand/hifmc100/Makefile
--- linux-4.9.37_original/drivers/mtd/nand/hifmc100/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/hifmc100/Makefile	2018-07-04 07:50:03.075724383 +0300
@@ -0,0 +1,26 @@
+#
+# The Flash Memory Controller v100 Device Driver for hisilicon
+#
+# Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+#
+# This program is free software; you can redistribute  it and/or modify it
+# under  the terms of  the GNU General  Public License as published by the
+# Free Software Foundation;  either version 2 of the  License, or (at your
+# option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+#
+
+#
+# drivers/mtd/nand/hifmc100/Makefile
+#
+
+obj-y	+= hifmc_spi_nand_ids.o
+obj-y	+= hifmc100.o hifmc100_os.o
diff -ruN linux-4.9.37_original/drivers/mtd/nand/hinfc_gen.c linux-4.9.37_modified/drivers/mtd/nand/hinfc_gen.c
--- linux-4.9.37_original/drivers/mtd/nand/hinfc_gen.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/hinfc_gen.c	2018-07-04 07:50:03.083724463 +0300
@@ -0,0 +1,244 @@
+/*
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+ 
+#include <linux/mfd/hisi_fmc.h>
+#include "match_table.h"
+#include "hinfc_gen.h"
+
+/*****************************************************************************/
+struct nand_flash_dev *(*get_spi_nand_flash_type_hook)(struct mtd_info *mtd,
+		unsigned char *id) = NULL;
+
+/*****************************************************************************/
+static struct match_t match_ecc[] = {
+	MATCH_SET_TYPE_DATA(NAND_ECC_NONE, "none"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_0BIT, "none"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_1BIT_512, "1bit/512"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_4BIT, "4bit/512"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_4BIT_512, "4bit/512"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_4BYTE, "4byte/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_8BIT, "4bit/512"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_8BIT_512, "8bit/512"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_8BYTE, "8byte/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_13BIT, "13bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_16BIT, "8bit/512"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_18BIT, "18bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_24BIT, "24bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_27BIT, "27bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_32BIT, "32bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_40BIT, "40bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_41BIT, "41bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_48BIT, "48bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_60BIT, "60bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_72BIT, "72bit/1k"),
+	MATCH_SET_TYPE_DATA(NAND_ECC_80BIT, "80bit/1k"),
+};
+
+const char *nand_ecc_name(int type)
+{
+	return (char *)match_type_to_data(match_ecc, ARRAY_SIZE(match_ecc),
+		type, "unknown");
+}
+
+char *get_ecctype_str(enum ecc_type ecctype)
+{
+	static char *ecctype_string[] = {
+		"None", "1bit/512Byte", "4bits/512Byte", "8bits/512Byte",
+		"24bits/1K", "40bits/1K", "unknown", "unknown"};
+	return ecctype_string[(ecctype & 0x07)];
+}
+
+/*****************************************************************************/
+static struct match_type_str page2name[] = {
+	{ NAND_PAGE_512B, "512" },
+	{ NAND_PAGE_2K,   "2K" },
+	{ NAND_PAGE_4K,   "4K" },
+	{ NAND_PAGE_8K,   "8K" },
+	{ NAND_PAGE_16K,  "16K" },
+	{ NAND_PAGE_32K,  "32K" },
+};
+
+const char *nand_page_name(int type)
+{
+	return type2str(page2name, ARRAY_SIZE(page2name), type, "unknown");
+}
+
+char *get_pagesize_str(enum page_type pagetype)
+{
+	static char *pagesize_str[] = {
+		"512", "2K", "4K", "8K", "16K", "unknown",
+		"unknown", "unknown"};
+	return pagesize_str[(pagetype & 0x07)];
+}
+
+/*****************************************************************************/
+static struct match_reg_type page2size[] = {
+	{ _512B, NAND_PAGE_512B },
+	{ _2K, NAND_PAGE_2K },
+	{ _4K, NAND_PAGE_4K },
+	{ _8K, NAND_PAGE_8K },
+	{ _16K, NAND_PAGE_16K },
+	{ _32K, NAND_PAGE_32K },
+};
+
+unsigned int get_pagesize(enum page_type pagetype)
+{
+	unsigned int pagesize[] = {
+		_512B, _2K, _4K, _8K, _16K, 0, 0, 0};
+	return pagesize[(pagetype & 0x07)];
+}
+
+int nandpage_size2type(int size)
+{
+	return reg2type(page2size, ARRAY_SIZE(page2size), size, NAND_PAGE_2K);
+}
+
+int nandpage_type2size(int size)
+{
+	return type2reg(page2size, ARRAY_SIZE(page2size), size, NAND_PAGE_2K);
+}
+
+char *nand_dbgfs_options;
+
+static int __init dbgfs_options_setup(char *s)
+{
+	nand_dbgfs_options = s;
+	return 1;
+}
+__setup("nanddbgfs=", dbgfs_options_setup);
+
+/*****************************************************************************/
+
+int get_bits(unsigned int n)
+{
+	int loop;
+	int ret = 0;
+
+	if (!n)
+		return 0;
+
+	if (n > 0xFFFF)
+		loop = n > 0xFFFFFF ? 32 : 24;
+	else
+		loop = n > 0xFF ? 16 : 8;
+
+	while (loop-- > 0 && n) {
+		if (n & 1)
+			ret++;
+		n >>= 1;
+	}
+	return ret;
+}
+
+/*****************************************************************************/
+#define et_ecc_none	0x00
+#define et_ecc_4bit	0x02
+#define et_ecc_8bit	0x03
+#define et_ecc_24bit1k	0x04
+#define et_ecc_40bit1k	0x05
+#define et_ecc_64bit1k	0x06
+
+static struct match_reg_type ecc_yaffs_type_t[] = {
+	{et_ecc_none,		NAND_ECC_0BIT},
+	{et_ecc_4bit,		NAND_ECC_8BIT},
+	{et_ecc_8bit,		NAND_ECC_16BIT},
+	{et_ecc_24bit1k,	NAND_ECC_24BIT},
+	{et_ecc_40bit1k,	NAND_ECC_40BIT},
+	{et_ecc_64bit1k,	NAND_ECC_64BIT}
+};
+
+unsigned char match_ecc_type_to_yaffs(unsigned char type)
+{
+	return type2reg(ecc_yaffs_type_t, ARRAY_SIZE(ecc_yaffs_type_t), type,
+			et_ecc_4bit);
+}
+
+/*****************************************************************************/
+static struct match_t page_table[] = {
+	{NAND_PAGE_2K,	PAGE_SIZE_2KB,	"2K"},
+	{NAND_PAGE_4K,	PAGE_SIZE_4KB,	"4K"},
+	{NAND_PAGE_8K,	PAGE_SIZE_8KB,	"8K"},
+	{NAND_PAGE_16K,	PAGE_SIZE_16KB,	"16K"},
+};
+
+unsigned char match_page_reg_to_type(unsigned char reg)
+{
+	return match_reg_to_type(page_table, ARRAY_SIZE(page_table), reg,
+			NAND_PAGE_2K);
+}
+
+unsigned char match_page_type_to_reg(unsigned char type)
+{
+	return match_type_to_reg(page_table, ARRAY_SIZE(page_table), type,
+			PAGE_SIZE_2KB);
+}
+
+const char *match_page_type_to_str(unsigned char type)
+{
+	return match_type_to_data(page_table, ARRAY_SIZE(page_table), type,
+			"unknown");
+}
+
+/*****************************************************************************/
+static struct match_t ecc_table[] = {
+	{NAND_ECC_0BIT,		ECC_TYPE_0BIT,	"none"},
+	{NAND_ECC_8BIT,		ECC_TYPE_8BIT,	"4bit/512"},
+	{NAND_ECC_16BIT,	ECC_TYPE_16BIT,	"8bit/512"},
+	{NAND_ECC_24BIT,	ECC_TYPE_24BIT,	"24bit/1K"},
+	{NAND_ECC_28BIT,	ECC_TYPE_28BIT,	"28bit/1K"},
+	{NAND_ECC_40BIT,	ECC_TYPE_40BIT,	"40bit/1K"},
+	{NAND_ECC_64BIT,	ECC_TYPE_64BIT,	"64bit/1K"},
+};
+
+unsigned char match_ecc_reg_to_type(unsigned char reg)
+{
+	return match_reg_to_type(ecc_table, ARRAY_SIZE(ecc_table), reg,
+			NAND_ECC_8BIT);
+}
+
+unsigned char match_ecc_type_to_reg(unsigned char type)
+{
+	return match_type_to_reg(ecc_table, ARRAY_SIZE(ecc_table), type,
+			ECC_TYPE_8BIT);
+}
+
+const char *match_ecc_type_to_str(unsigned char type)
+{
+	return match_type_to_data(ecc_table, ARRAY_SIZE(ecc_table), type,
+			"unknown");
+}
+
+/*****************************************************************************/
+static struct match_t page_type_size_table[] = {
+	{NAND_PAGE_2K,	_2K,	NULL},
+	{NAND_PAGE_4K,	_4K,	NULL},
+	{NAND_PAGE_8K,	_8K,	NULL},
+	{NAND_PAGE_16K,	_16K,	NULL},
+};
+
+unsigned char match_page_size_to_type(unsigned int size)
+{
+	return match_reg_to_type(page_type_size_table,
+			ARRAY_SIZE(page_type_size_table), size, NAND_PAGE_2K);
+}
+
+unsigned int match_page_type_to_size(unsigned char type)
+{
+	return match_type_to_reg(page_type_size_table,
+			ARRAY_SIZE(page_type_size_table), type, _2K);
+}
diff -ruN linux-4.9.37_original/drivers/mtd/nand/hinfc_gen.h linux-4.9.37_modified/drivers/mtd/nand/hinfc_gen.h
--- linux-4.9.37_original/drivers/mtd/nand/hinfc_gen.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/hinfc_gen.h	2018-07-04 07:50:03.083724463 +0300
@@ -0,0 +1,294 @@
+/*
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __HINFC_GEN_H__
+#define __HINFC_GEN_H__
+
+/*****************************************************************************/
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/string_helpers.h>
+#include <asm/setup.h>
+#include <linux/module.h>
+
+/*****************************************************************************/
+#define HINFC_VER_300                   (0x300)
+#define HINFC_VER_301                   (0x301)
+#define HINFC_VER_310                   (0x310)
+#define HINFC_VER_504                   (0x504)
+#define HINFC_VER_505                   (0x505)
+#define HINFC_VER_600                   (0x600)
+#define HINFC_VER_610                   (0x610)
+#define HINFC_VER_620                   (0x620)
+
+#define HISNFC_VER_100                  (0x400)
+
+/*****************************************************************************/
+#define NAND_PAGE_512B                   0
+#define NAND_PAGE_1K                     1
+#define NAND_PAGE_2K                     2
+#define NAND_PAGE_4K                     3
+#define NAND_PAGE_8K                     4
+#define NAND_PAGE_16K                    5
+#define NAND_PAGE_32K                    6
+
+/*****************************************************************************/
+#define NAND_ECC_NONE                    0
+#define NAND_ECC_0BIT                    0
+#define NAND_ECC_1BIT                    1
+#define NAND_ECC_1BIT_512                1
+#define NAND_ECC_4BIT                    2
+#define NAND_ECC_4BIT_512                2
+#define NAND_ECC_4BYTE                   2
+#define NAND_ECC_8BIT                    2
+#define NAND_ECC_8BIT_512                3
+#define NAND_ECC_8BYTE                   3
+#define NAND_ECC_13BIT                   4
+#define NAND_ECC_16BIT                   5
+#define NAND_ECC_18BIT                   6
+#define NAND_ECC_24BIT                   7
+#define NAND_ECC_27BIT                   8
+#define NAND_ECC_28BIT                   9
+#define NAND_ECC_32BIT                   10
+#define NAND_ECC_40BIT                   11
+#define NAND_ECC_41BIT                   12
+#define NAND_ECC_42BIT                   13
+#define NAND_ECC_48BIT                   14
+#define NAND_ECC_60BIT                   15
+#define NAND_ECC_64BIT                   16
+#define NAND_ECC_72BIT                   17
+#define NAND_ECC_80BIT                   18
+
+enum ecc_type {
+	et_ecc_none    = 0x00,
+	et_ecc_1bit    = 0x01,
+	et_ecc_4bit    = 0x02,
+	et_ecc_8bit    = 0x03,
+	et_ecc_24bit1k = 0x04,
+	et_ecc_40bit1k = 0x05,
+	et_ecc_64bit1k = 0x06,
+};
+
+enum page_type {
+	pt_pagesize_512   = 0x00,
+	pt_pagesize_2K    = 0x01,
+	pt_pagesize_4K    = 0x02,
+	pt_pagesize_8K    = 0x03,
+	pt_pagesize_16K   = 0x04,
+};
+
+/*****************************************************************************/
+struct nand_config_info {
+	unsigned int pagetype;
+	unsigned int ecctype;
+	unsigned int ecc_strength;
+	unsigned int oobsize;
+	struct mtd_ooblayout_ops *ooblayout_ops;
+};
+
+struct hinfc_host;
+
+struct nand_sync {
+
+#define SET_NAND_SYNC_TYPE(_mfr, _onfi, _version) \
+	((((_mfr) & 0xFF) << 16) | (((_version) & 0xFF) << 8) \
+	 | ((_onfi) & 0xFF))
+
+#define GET_NAND_SYNC_TYPE_MFR(_type) (((_type) >> 16) & 0xFF)
+#define GET_NAND_SYNC_TYPE_VER(_type) (((_type) >> 8) & 0xFF)
+#define GET_NAND_SYNC_TYPE_INF(_type) ((_type) & 0xFF)
+
+#define NAND_TYPE_ONFI_23_MICRON    \
+	SET_NAND_SYNC_TYPE(NAND_MFR_MICRON, NAND_IS_ONFI, 0x23)
+#define NAND_TYPE_ONFI_30_MICRON    \
+	SET_NAND_SYNC_TYPE(NAND_MFR_MICRON, NAND_IS_ONFI, 0x30)
+#define NAND_TYPE_TOGGLE_TOSHIBA    \
+	SET_NAND_SYNC_TYPE(NAND_MFR_TOSHIBA, 0, 0)
+#define NAND_TYPE_TOGGLE_SAMSUNG    \
+	SET_NAND_SYNC_TYPE(NAND_MFR_SAMSUNG, 0, 0)
+
+#define NAND_TYPE_TOGGLE_10         SET_NAND_SYNC_TYPE(0, 0, 0x10)
+#define NAND_TYPE_ONFI_30           SET_NAND_SYNC_TYPE(0, NAND_IS_ONFI, 0x30)
+#define NAND_TYPE_ONFI_23           SET_NAND_SYNC_TYPE(0, NAND_IS_ONFI, 0x23)
+
+	int type;
+	int (*enable)(struct nand_chip *chip);
+	int (*disable)(struct nand_chip *chip);
+};
+
+struct read_retry_t {
+	int type;
+	int count;
+	int (*set_rr_param)(struct hinfc_host *host, int param);
+	int (*get_rr_param)(struct hinfc_host *host);
+	int (*reset_rr_param)(struct hinfc_host *host);
+};
+
+struct ecc_info_t {
+	int pagesize;
+	int ecctype;
+	int threshold;
+	int section;
+	void (*dump)(struct hinfc_host *host, unsigned char ecc[],
+		     int *max_bitsflag);
+};
+
+struct nand_dev_t {
+	struct nand_flash_dev flash_dev;
+
+	char *start_type;
+	unsigned char ids[8];
+	int oobsize;
+	int ecctype;
+
+	/* (Controller) support ecc/page detect, driver don't need detect */
+#define NANDC_HW_AUTO                         0x01
+	/* (Controller) support ecc/page detect,
+	 * and current ecc/page config finish */
+#define NANDC_CONFIG_DONE                     0x02
+	/* (Controller) is sync, default is async */
+#define NANDC_IS_SYNC_BOOT                    0x04
+
+/* (NAND) need randomizer */
+#define NAND_RANDOMIZER                       0x10
+/* (NAND) is ONFI interface, combine with sync/async symble */
+#define NAND_IS_ONFI                          0x20
+/* (NAND) support async and sync, such micron onfi, toshiba toggle 1.0 */
+#define NAND_MODE_SYNC_ASYNC                  0x40
+/* (NAND) support only sync, such samsung sync. */
+#define NAND_MODE_ONLY_SYNC                   0x80
+
+#define NAND_CHIP_MICRON   (NAND_MODE_SYNC_ASYNC | NAND_IS_ONFI)
+/* This NAND is async, or sync/async, default is async mode,
+ * toggle1.0 interface */
+#define NAND_CHIP_TOSHIBA_TOGGLE_10  (NAND_MODE_SYNC_ASYNC)
+/* This NAND is only sync mode, toggle2.0 interface */
+#define NAND_CHIP_TOSHIBA_TOGGLE_20   (NAND_MODE_ONLY_SYNC)
+/* This NAND is only sync mode */
+#define NAND_CHIP_SAMSUNG  (NAND_MODE_ONLY_SYNC)
+
+	unsigned int flags;
+
+#define NAND_RR_NONE                   0x00
+#define NAND_RR_HYNIX_BG_BDIE          0x10
+#define NAND_RR_HYNIX_BG_CDIE          0x11
+#define NAND_RR_HYNIX_CG_ADIE          0x12
+#define NAND_RR_MICRON                 0x20
+#define NAND_RR_SAMSUNG                0x30
+#define NAND_RR_TOSHIBA_24nm           0x40
+#define NAND_RR_TOSHIBA_19nm           0x41
+	int read_retry_type;
+};
+
+/*****************************************************************************/
+
+#define IS_NANDC_HW_AUTO(_host)         ((_host)->flags & NANDC_HW_AUTO)
+#define IS_NANDC_CONFIG_DONE(_host)     ((_host)->flags & NANDC_CONFIG_DONE)
+#define IS_NANDC_SYNC_BOOT(_host)       ((_host)->flags & NANDC_IS_SYNC_BOOT)
+
+#define IS_NAND_RANDOM(_dev)         ((_dev)->flags & NAND_RANDOMIZER)
+#define IS_NAND_ONLY_SYNC(_dev)      ((_dev)->flags & NAND_MODE_ONLY_SYNC)
+#define IS_NAND_SYNC_ASYNC(_dev)     ((_dev)->flags & NAND_MODE_SYNC_ASYNC)
+#define IS_NAND_ONFI(_dev)           ((_dev)->flags & NAND_IS_ONFI)
+
+#define ERSTR_HARDWARE  "Hardware configuration error. "
+#define ERSTR_DRIVER    "Driver does not support. "
+
+#define ENABLE                    1
+#define DISABLE                   0
+
+/*****************************************************************************/
+
+char *get_ecctype_str(enum ecc_type ecctype);
+
+char *get_pagesize_str(enum page_type pagetype);
+
+unsigned int get_pagesize(enum page_type pagetype);
+
+const char *nand_ecc_name(int type);
+
+const char *nand_page_name(int type);
+
+int nandpage_size2type(int size);
+
+int nandpage_type2size(int size);
+
+/*****************************************************************************/
+extern int (*hinfc_param_adjust)(struct mtd_info *mtd, struct nand_chip *chip,
+	struct nand_dev_t *nand_dev);
+
+extern struct nand_flash_dev *(*nand_get_flash_type_func)(struct mtd_info *mtd,
+	struct nand_chip *chip, struct nand_dev_t *spinand_dev_t);
+
+extern struct nand_flash_dev *(*get_spi_nand_flash_type_hook)
+		(struct mtd_info *mtd, unsigned char *id);
+
+extern int (*hinfc_param_adjust)(struct mtd_info *,
+		struct nand_chip *, struct nand_dev_t *);
+
+/*****************************************************************************/
+struct nand_flash_dev *hinfc_get_flash_type(struct mtd_info *mtd,
+	struct nand_chip *chip, u8 *id_data, int *busw);
+
+extern struct nand_flash_dev *(*get_spi_nand_flash_type_hook)
+	(struct mtd_info *mtd, unsigned char *id);
+
+void hinfc_nand_param_adjust(struct mtd_info *mtd, struct nand_chip *chip);
+
+void hinfc_show_info(struct mtd_info *mtd, char *vendor, char *chipname);
+
+void hinfc_show_chipsize(struct nand_chip *chip);
+
+int get_bits(unsigned int n);
+
+/*****************************************************************************/
+#define hinfc_pr_msg(_fmt, arg...) printk(_fmt, ##arg)
+
+#define hinfc_pr_bug(fmt, args...) do { \
+	printk("%s(%d): bug " fmt, __FILE__, __LINE__, ##args); \
+	while (1) \
+		; \
+} while (0)
+
+#define PR_MSG(_fmt, arg...) \
+	    printk(_fmt, ##arg)
+
+extern char *nand_dbgfs_options;
+/*****************************************************************************/
+extern unsigned char match_page_reg_to_type(unsigned char reg);
+
+extern unsigned char match_page_type_to_reg(unsigned char type);
+
+extern const char *match_page_type_to_str(unsigned char type);
+
+/*****************************************************************************/
+extern unsigned char match_ecc_reg_to_type(unsigned char reg);
+
+extern unsigned char match_ecc_type_to_reg(unsigned char type);
+
+extern const char *match_ecc_type_to_str(unsigned char type);
+
+/*****************************************************************************/
+extern unsigned char match_page_size_to_type(unsigned int size);
+
+extern unsigned int match_page_type_to_size(unsigned char type);
+
+const char *nand_ecc_name(int type);
+/*****************************************************************************/
+
+#endif /* End of __HINFC_GEN_H__ */
diff -ruN linux-4.9.37_original/drivers/mtd/nand/hinfc_spl_ids.c linux-4.9.37_modified/drivers/mtd/nand/hinfc_spl_ids.c
--- linux-4.9.37_original/drivers/mtd/nand/hinfc_spl_ids.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/hinfc_spl_ids.c	2018-07-04 07:50:03.083724463 +0300
@@ -0,0 +1,979 @@
+/*
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mfd/hisi_fmc.h>
+#include "hinfc_gen.h"
+
+/*****************************************************************************/
+
+struct nand_flash_special_dev {
+	unsigned char id[8];
+	int length;             /* length of id. */
+	unsigned long long chipsize;
+	struct nand_flash_dev *(*probe)(struct nand_dev_t *nand_dev);
+	char *name;
+
+	unsigned long pagesize;
+	unsigned long erasesize;
+	unsigned long oobsize;
+	unsigned long options;
+	unsigned int read_retry_type;
+
+#define BBP_LAST_PAGE                    0x01
+#define BBP_FIRST_PAGE                   0x02
+	unsigned int badblock_pos;
+	unsigned int flags;
+};
+
+/*****************************************************************************/
+/*                    this is nand probe function.                           */
+/*****************************************************************************/
+
+static struct nand_flash_dev *hynix_probe_v02(
+	struct nand_dev_t *nand_dev)
+{
+	unsigned char *id = nand_dev->ids;
+	struct nand_flash_dev *type = &nand_dev->flash_dev;
+
+	int pagesizes[]   = {SZ_2K, SZ_4K, SZ_8K, 0};
+	int oobsizes[]    = {128, 224, 448, 0, 0, 0, 0, 0};
+	int blocksizes[]  = {SZ_128K, SZ_256K, SZ_512K,
+				(SZ_256K + SZ_512K), SZ_1M, SZ_2M, 0, 0};
+
+	int blocktype = (((id[3] >> 5) & 0x04) | ((id[3] >> 4) & 0x03));
+	int oobtype   = (((id[3] >> 2) & 0x03) | ((id[3] >> 4) & 0x04));
+
+	type->options   = 0;
+	type->pagesize  = pagesizes[(id[3] & 0x03)];
+	type->erasesize = blocksizes[blocktype];
+	nand_dev->oobsize = oobsizes[oobtype];
+
+	return type;
+}
+/*****************************************************************************/
+
+static struct nand_flash_dev *samsung_probe_v02(
+	struct nand_dev_t *nand_dev)
+{
+	unsigned char *id = nand_dev->ids;
+	struct nand_flash_dev *type = &nand_dev->flash_dev;
+
+	int pagesizes[]   = {SZ_2K, SZ_4K, SZ_8K, 0};
+	int oobsizes[]    = {0, 128, 218, 400, 436, 0, 0, 0};
+	int blocksizes[]  = {SZ_128K, SZ_256K, SZ_512K, SZ_1M, 0, 0, 0, 0};
+
+	int blocktype = (((id[3] >> 5) & 0x04) | ((id[3] >> 4) & 0x03));
+	int oobtype   = (((id[3] >> 4) & 0x04) | ((id[3] >> 2) & 0x03));
+
+	type->options   = 0;
+	type->pagesize  = pagesizes[(id[3] & 0x03)];
+	type->erasesize = blocksizes[blocktype];
+	nand_dev->oobsize = oobsizes[oobtype];
+
+	return type;
+}
+/*****************************************************************************/
+
+#define DRV_VERSION     "1.38"
+
+/*****************************************************************************/
+/*
+ * samsung:  27nm need randomizer, 21nm need read retry;
+ * micron:   25nm need read retry, datasheet will explain read retry.
+ * toshaba   32nm need randomizer, 24nm need read retry.
+ * hynix:    2xnm need read retry.
+ *
+ *		The special nand flash ID table version 1.37
+ *
+ * manufactory  |  type  |       name 	     |   ecc_type  | version_tag
+ * Micron		|  MLC	 |  MT29F64G08CBABA  |   40bit/1k  |  1.36
+ * Micron		|  MLC	 |  MT29F32G08CBADA  |   40bit/1k  |
+ * Micron		|  SLC	 |  MT29F8G08ABxBA   |   4bit/512  |
+ * Micron		|  MLC	 |  MT29F16G08CBABx  |   12bit/512 |
+ * Micron		|  MLC	 |  MT29F16G08CBACA  |   24bit/1k  |
+ * Micron		|  MLC	 |  MT29F32G08CBACA  |   24bit/1k  |
+ * Micron		|  MLC	 |  MT29F64G08CxxAA  |   24bit/1k  |
+ * Micron		|  MLC	 |  MT29F256G08CJAAA |   24bit/1k  |   2CE
+ * Micron		|  MLC	 |  MT29F256G08CMCBB |   24bit/1k  |
+ * Micron		|  SLC	 |  MT29F8G08ABACA   |   8bit/512  |
+ * Micron		|  SLC	 |  MT29F4G08ABAEA   |   8bit/512  |
+ * Micron		|  SLC	 |  MT29F2G08ABAFA   |   8bit/512  |
+ * Micron		|  SLC	 |  MT29F16G08ABACA  |   8bit/512  |
+ * Toshiba		|  MLC   |  TC58NVG4D2FTA00  |   24bit/1k  |
+ * Toshiba		|  MLC   |  TH58NVG6D2FTA20  |   24bit/1k  |   2CE
+ * Toshiba		|  MLC   |  TC58NVG5D2HTA00  |   40bit/1k  |
+ * Toshiba		|  MLC   |  TC58NVG6D2GTA00  |   40bit/1k  |
+ * Toshiba		|  MLC   |  TC58NVG6DCJTA00  |			   |
+ * Toshiba		|  MLC   |  TC58TEG5DCJTA00  |			   |
+ * Toshiba		|  SLC   |  TC58NVG0S3HTA00  |   8bit/512  |
+ * Toshiba		|  SLC   |  TC58NVG1S3HTA00  |   8bit/512  |
+ * Toshiba		|  SLC   |  TC58NVG1S3ETA00  |   4bit/512  |
+ * Toshiba		|  SLC   |  TC58NVG3S0FTA00  |   4bit/512  |
+ * Toshiba		|  SLC   |  TC58NVG2S0FTA00  |   4bit/512  |
+ * Toshiba		|  SLC   |  TH58NVG2S3HTA00  |   4bit/512  |
+ * Toshiba		|  TLC   |  TC58NVG5T2JTA00  |   60bit/1k  |
+ * Toshiba		|  TLC   |  TC58TEG5DCKTAx0  |   60bit/1k  |
+ * Toshiba		|  MLC   |  Tx58TEGxDDKTAx0  |			   |
+ * Samsung		|  MLC   |  K9LB(HC/PD/MD)G08U0(1)D  |   8bit/512B  |
+ * Samsung		|  MLC   |  K9GAG08U0E	     |   24bit/1KB |
+ * Samsung		|  MLC   |  K9LBG08U0E	     |   24bit/1KB |
+ * Samsung		|  MLC   |  K9G8G08U0C	     |   24bit/1KB |
+ * Samsung		|  MLC   |  K9GAG08U0F	     |   24bit/1KB |
+ * Samsung		|  MLC   |  K9LBG08U0M	     |             |
+ * Samsung		|  MLC   |  K9GBG08U0A	     |   24bit/1KB |
+ * Samsung		|  MLC   |  K9GBG08U0B	     |   40bit/1KB |
+ * Hynix		|  MLC   |  H27UAG8T2A	     |			   |
+ * Hynix		|  MLC   |  H27UAG8T2B	     |			   |
+ * Hynix		|  MLC   |  H27UBG8T2A	     |			   |
+ * Hynix		|  MLC   |  H27UBG8T2BTR	 |	 24bit/1KB |
+ * Hynix		|  MLC   |  H27UCG8T2A		 |	 40bit/1KB |
+ * Hynix		|  MLC   |  H27UBG8T2C		 |	 40bit/1KB |
+ * MISC			|  MLC   |  P1UAGA30AT-GCA	 |	 8bit/512  |
+ * MISC			|  MLC   |  PSU8GA30AT-GIA/ASU8GA30IT-G30CA	 |	 4bit/512  |
+ * MISC			|  SLC   |  PSU2GA30AT   	 |	 1bit/512  |   1.36
+ * Toshiba		|  SLC   |  TC58NVG2S0HTA00  |	 24bit/1K  |   1.37
+ * Toshiba		|  SLC   |  TC58NVG3S0HTA00  |   24bit/1K  |   1.37
+ * Micron		|  SLC	 |  MT29F2G08ABAEA   |   4bit/512 |
+ * Spansion		|  SLC	 | S34ML02G200TFI000	 | 24bit/1K |
+ * Spansion		|  SLC	 | S34ML04G200TFI000	 | 24bit/1K |  1.38
+ *
+ */
+
+static struct nand_flash_special_dev nand_flash_special_dev[] = {
+
+/****************************** Spansion *******************************/
+
+	{		/* SLC S34ML02G200TFI000 */
+		.name      = "S34ML02G200TFI000",
+		.id        = {0x01, 0xDA, 0x90, 0x95, 0x46, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _256M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+
+	{		/* SLC S34ML04G200TFI000 */
+		.name      = "S34ML04G200TFI000",
+		.id        = {0x01, 0xDC, 0x90, 0x95, 0x56, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _512M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+
+/****************************** Micron *******************************/
+	{        /* MLC 40bit/1k */
+		.name      = "MT29F64G08CBABA",
+		.id        = {0x2C, 0x64, 0x44, 0x4B, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 744,
+		.options   = 0,
+		.read_retry_type = NAND_RR_MICRON,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = NAND_RANDOMIZER | NAND_CHIP_MICRON,
+	},
+	{        /* MLC 40bit/1k */
+		.name      = "MT29F32G08CBADA",
+		.id        = {0x2C, 0x44, 0x44, 0x4B, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 744,
+		.options   = 0,
+		.read_retry_type = NAND_RR_MICRON,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{        /* SLC 4bit/512 */
+		.name      = "MT29F8G08ABxBA",
+		.id        = {0x2C, 0x38, 0x00, 0x26, 0x85, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = SZ_1G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_512K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 12bit/512 */
+		.name      = "MT29F16G08CBABx",
+		.id        = {0x2C, 0x48, 0x04, 0x46, 0x85, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = SZ_2G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_1M,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k */
+		.name      = "MT29F16G08CBACA",
+		.id        = {0x2C, 0x48, 0x04, 0x4A, 0xA5, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = SZ_2G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_1M,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k */
+		.name      = "MT29F32G08CBACA",
+		.id        = {0x2C, 0x68, 0x04, 0x4A, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_1M,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k */
+		.name      = "MT29F64G08CxxAA",
+		.id        = {0x2C, 0x88, 0x04, 0x4B, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 448,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k 2CE */
+		.name      = "MT29F256G08CJAAA",
+		.id        = {0x2C, 0xA8, 0x05, 0xCB, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _16G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 448,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 40bit/1k */
+		.name      = "MT29F256G08CMCBB",
+		.id        = {0x2C, 0x64, 0x44, 0x4B, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 8,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 744,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* SLC 8bit/512 */
+		.name      = "MT29F8G08ABACA",
+		.id        = {0x2C, 0xD3, 0x90, 0xA6, 0x64, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = SZ_1G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_256K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* SLC 8bit/512 */
+		.name      = "MT29F4G08ABAEA",
+		.id        = {0x2C, 0xDC, 0x90, 0xA6, 0x54, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = SZ_512M,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_256K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* SLC 8bit/512 */
+		.name      = "MT29F2G08ABAFA",
+		.id        = {0x2C, 0xDA, 0x90, 0x95, 0x04, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = SZ_256M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{		/* SLC MT29F2G08ABAEA */
+		.name      = "MT29F2G08ABAEA",
+		.id        = {0x2C, 0xDA, 0x90, 0x95, 0x06, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _256M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 64,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{        /* SLC 8bit/512 */
+		.name      = "MT29F16G08ABACA",
+		.id        = {0x2C, 0x48, 0x00, 0x26, 0xA9, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = SZ_2G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_512K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+
+/****************************** Toshaba *******************************/
+
+	{       /* MLC 24bit/1k 32nm */
+		.name      = "TC58NVG4D2FTA00",
+		.id        = {0x98, 0xD5, 0x94, 0x32, 0x76, 0x55, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = SZ_2G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_1M,
+		.oobsize   = 448,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 24bit/1k 32nm 2CE*/
+		.name      = "TH58NVG6D2FTA20",
+		.id        = {0x98, 0xD7, 0x94, 0x32, 0x76, 0x55, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_1M,
+		.oobsize   = 448,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 40bit/1k 24nm */
+		.name      = "TC58NVG5D2HTA00 24nm",
+		.id        = {0x98, 0xD7, 0x94, 0x32, 0x76, 0x56, 0x08, 0x00},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_1M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_24nm,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{       /* MLC 40bit/1k */
+		.name      = "TC58NVG6D2GTA00",
+		.id        = {0x98, 0xDE, 0x94, 0x82, 0x76, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 19nm */
+		.name      = "TC58NVG6DCJTA00 19nm",
+		.id        = {0x98, 0xDE, 0x84, 0x93, 0x72, 0x57, 0x08, 0x04},
+		.length    = 8,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = SZ_16K,
+		.erasesize = SZ_4M,
+		.oobsize   = 1280,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_24nm,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{       /* MLC 19nm */
+		.name      = "TC58TEG5DCJTA00 19nm",
+		.id        = {0x98, 0xD7, 0x84, 0x93, 0x72, 0x57, 0x08, 0x04},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_16K,
+		.erasesize = SZ_4M,
+		.oobsize   = 1280,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_24nm,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER | NAND_CHIP_TOSHIBA_TOGGLE_10,
+	},
+	{       /* SLC 8bit/512 */
+		.name      = "TC58NVG0S3HTA00",
+		.id        = {0x98, 0xF1, 0x80, 0x15, 0x72, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = SZ_128M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		/*
+		 * Datasheet: read one column of any page in each block. If the
+		 * data of the column is 00 (Hex), define the block as a bad
+		 * block.
+		 */
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 8bit/512 */
+		.name      = "TC58NVG1S3HTA00",
+		.id        = {0x98, 0xDA, 0x90, 0x15, 0x76, 0x16, 0x08, 0x00},
+		.length    = 7,
+		.chipsize  = SZ_256M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 4bit/512 */
+		.name      = "TC58NVG1S3ETA00",
+		.id        = {0x98, 0xDA, 0x90, 0x15, 0x76, 0x14, 0x03, 0x00},
+		.length    = 7,
+		.chipsize  = SZ_256M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 64,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 4bit/512 */
+		.name      = "TC58NVG3S0FTA00",
+		.id        = {0x98, 0xD3, 0x90, 0x26, 0x76, 0x15, 0x02, 0x08},
+		.length    = 8,
+		.chipsize  = SZ_1G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_256K,
+		.oobsize   = 232,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 4bit/512 */
+		.name      = "TC58NVG3S0HTA00",
+		.id        = {0x98, 0xD3, 0x91, 0x26, 0x76, 0x16, 0x08, 0x00},
+		.length    = 8,
+		.chipsize  = SZ_1G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_256K,
+		.oobsize   = 256,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 24bit/1k */
+		.name      = "TC58NVG2S0HTA00",
+		.id        = {0x98, 0xDC, 0x90, 0x26, 0x76, 0x16, 0x08, 0x00},
+		.length    = 8,
+		.chipsize  = SZ_512M,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_256K,
+		.oobsize   = 256,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 4bit/512 */
+		.name      = "TC58NVG2S0FTA00",
+		.id        = {0x98, 0xDC, 0x90, 0x26, 0x76, 0x15, 0x01, 0x08},
+		.length    = 8,
+		.chipsize  = SZ_512M,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_256K,
+		.oobsize   = 224,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* SLC 4bit/512 */
+		.name      = "TH58NVG2S3HTA00",
+		.id        = {0x98, 0xDC, 0x91, 0x15, 0x76},
+		.length    = 5,
+		.chipsize  = SZ_512M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE,
+		.flags = 0,
+	},
+	{       /* TLC 60bit/1k 19nm */
+		.name      = "TC58NVG5T2JTA00 19nm TLC",
+		.id        = {0x98, 0xD7, 0x98, 0x92, 0x72, 0x57, 0x08, 0x10},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_4M,
+		.oobsize   = 1024,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_24nm,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{	/* TLC 60bit/1k 19nm */
+		.name	   = "TC58TEG5DCKTAx0 19nm MLC",
+		/* datasheet says 6 ids id data, but really has 8 ids. */
+		.id	   = {0x98, 0xD7, 0x84, 0x93, 0x72, 0x50, 0x08, 0x04},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe	   = NULL,
+		.pagesize  = SZ_16K,
+		.erasesize = SZ_4M,
+		.oobsize   = 1280,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_19nm,
+		.badblock_pos	 = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{
+		.name	   = "Tx58TEGxDDKTAx0 19nm MLC",
+		.id	   = {0x98, 0xDE, 0x94, 0x93, 0x76, 0x50},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe	   = NULL,
+		.pagesize  = SZ_16K,
+		.erasesize = SZ_4M,
+		.oobsize   = 1280,
+		.options   = 0,
+		.read_retry_type = NAND_RR_TOSHIBA_19nm,
+		.badblock_pos	 = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+/******************************* Samsung ******************************/
+	{       /* MLC 8bit/512B */
+		.name     = "K9LB(HC/PD/MD)G08U0(1)D",
+		.id       = {0xEC, 0xD7, 0xD5, 0x29, 0x38, 0x41, 0x00, 0x00},
+		.length   = 6,
+		.chipsize = _4G,
+		.probe    = samsung_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 24bit/1KB */
+		.name      = "K9GAG08U0E",
+		.id        = {0xEC, 0xD5, 0x84, 0x72, 0x50, 0x42, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = SZ_2G,
+		.probe     = samsung_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 24bit/1KB */
+		.name     = "K9LBG08U0E",
+		.id       = {0xEC, 0xD7, 0xC5, 0x72, 0x54, 0x42, 0x00, 0x00},
+		.length   = 6,
+		.chipsize = _4G,
+		.probe    = samsung_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 24bit/1KB */
+		.name     = "K9G8G08U0C",
+		.id       = {0xEC, 0xD3, 0x84, 0x72, 0x50, 0x42, 0x00, 0x00},
+		.length   = 6,
+		.chipsize = SZ_1G,
+		.probe    = samsung_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k */
+		.name      = "K9GAG08U0F",
+		.id        = {0xEC, 0xD5, 0x94, 0x76, 0x54, 0x43, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = SZ_2G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_1M,
+		.oobsize   = 512,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC */
+		.name      = "K9LBG08U0M",
+		.id        = {0xEC, 0xD7, 0x55, 0xB6, 0x78, 0x00, 0x00, 0x00},
+		.length    = 5,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_512K,
+		.oobsize   = 128,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{        /* MLC 24bit/1k */
+		.name      = "K9GBG08U0A 20nm",
+		.id        = {0xEC, 0xD7, 0x94, 0x7A, 0x54, 0x43, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_1M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_SAMSUNG,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{        /* MLC 40bit/1k */
+		.name      = "K9GBG08U0B",
+		.id        = {0xEC, 0xD7, 0x94, 0x7E, 0x64, 0x44, 0x00, 0x00},
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_1M,
+		.oobsize   = 1024,
+		.options   = 0,
+		.read_retry_type = NAND_RR_SAMSUNG,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+
+/*********************************** Hynix ****************************/
+	{       /* MLC */
+		.name     = "H27UAG8T2A",
+		.id       = {0xAD, 0xD5, 0x94, 0x25, 0x44, 0x41, },
+		.length   = 6,
+		.chipsize = SZ_2G,
+		.probe    = hynix_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC */
+		.name     = "H27UAG8T2B",
+		.id       = {0xAD, 0xD5, 0x94, 0x9A, 0x74, 0x42, },
+		.length   = 6,
+		.chipsize = SZ_2G,
+		.probe    = hynix_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC */
+		.name     = "H27UBG8T2A",
+		.id       = {0xAD, 0xD7, 0x94, 0x9A, 0x74, 0x42, },
+		.length   = 6,
+		.chipsize = _4G,
+		.probe    = hynix_probe_v02,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 24bit/1K, 26nm TODO: Need read retry, chip is EOS */
+		.name      = "H27UBG8T2BTR 26nm",
+		.id        = {0xAD, 0xD7, 0x94, 0xDA, 0x74, 0xC3, },
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_HYNIX_BG_BDIE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{        /* MLC 40bit/1k */
+		.name      = "H27UCG8T2A",
+		.id        = {0xAD, 0xDE, 0x94, 0xDA, 0x74, 0xC4, },
+		.length    = 6,
+		.chipsize  = _8G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_HYNIX_CG_ADIE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+	{        /* MLC 40bit/1k */
+		.name      = "H27UBG8T2C",
+		.id        = {0xAD, 0xD7, 0x94, 0x91, 0x60, 0x44, },
+		.length    = 6,
+		.chipsize  = _4G,
+		.probe     = NULL,
+		.pagesize  = SZ_8K,
+		.erasesize = SZ_2M,
+		.oobsize   = 640,
+		.options   = 0,
+		.read_retry_type = NAND_RR_HYNIX_BG_CDIE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = NAND_RANDOMIZER,
+	},
+
+/********************** MISC ******************************************/
+	{        /* MLC 8bit/512 */
+		.name      = "P1UAGA30AT-GCA",
+		.id        = {0xC8, 0xD5, 0x14, 0x29, 0x34, 0x01, },
+		.length    = 6,
+		.chipsize  = SZ_2G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_512K,
+		.oobsize   = 218,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{       /* MLC 4bit/512 */
+		/*
+		 * PowerFlash ASU8GA30IT-G30CA ID and MIRA PSU8GA30AT-GIA ID are
+		 * the same ID
+		 */
+		.name      = "PSU8GA30AT-GIA/ASU8GA30IT-G30CA",
+		.id        = {0xC8, 0xD3, 0x90, 0x19, 0x34, 0x01, },
+		.length    = 6,
+		.chipsize  = SZ_1G,
+		.probe     = NULL,
+		.pagesize  = SZ_4K,
+		.erasesize = SZ_256K,
+		.oobsize   = 218,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{        /* SLC 1bit/512 */
+		.name      = "PSU2GA30AT",
+		.id        = {0x7F, 0x7F, 0x7F, 0x7F, 0xC8, 0xDA, 0x00, 0x15, },
+		.length    = 8,
+		.chipsize  = SZ_256M,
+		.probe     = NULL,
+		.pagesize  = SZ_2K,
+		.erasesize = SZ_128K,
+		.oobsize   = 64,
+		.options   = 0,
+		.read_retry_type = NAND_RR_NONE,
+		.badblock_pos    = BBP_FIRST_PAGE | BBP_LAST_PAGE,
+		.flags = 0,
+	},
+	{{0}, 0, 0, 0, 0, 0, 0, 0, 0},
+};
+
+#define NUM_OF_SPECIAL_DEVICE  \
+	(sizeof(nand_flash_special_dev)/sizeof(struct nand_flash_special_dev))
+
+int (*hinfc_param_adjust)(struct mtd_info *, struct nand_chip *,
+			struct nand_dev_t *) = NULL;
+
+static struct nand_dev_t __nand_dev;
+/*****************************************************************************/
+
+static struct nand_flash_dev *hinfc_nand_probe(struct mtd_info *mtd,
+					       struct nand_chip *chip,
+					       struct nand_dev_t *nand_dev)
+{
+	struct nand_flash_special_dev *spl_dev;
+	unsigned char *byte = nand_dev->ids;
+	struct nand_flash_dev *type = &nand_dev->flash_dev;
+
+	hinfc_pr_msg("Nand ID: 0x%02X 0x%02X 0x%02X 0x%02X",
+			byte[0], byte[1], byte[2], byte[3]);
+	hinfc_pr_msg(" 0x%02X 0x%02X 0x%02X 0x%02X\n",
+			byte[4], byte[5], byte[6], byte[7]);
+
+	for (spl_dev = nand_flash_special_dev; spl_dev->length; spl_dev++) {
+		if (memcmp(byte, spl_dev->id, spl_dev->length))
+			continue;
+
+		hinfc_pr_msg("The Special NAND id table Version: %s\n", DRV_VERSION);
+
+		if (spl_dev->probe) {
+			type = spl_dev->probe(nand_dev);
+		} else {
+			type->options   = spl_dev->options;
+			type->pagesize  = spl_dev->pagesize;
+			type->erasesize = spl_dev->erasesize;
+			nand_dev->oobsize = spl_dev->oobsize;
+		}
+
+		nand_dev->read_retry_type = spl_dev->read_retry_type;
+		nand_dev->flags = spl_dev->flags;
+
+		type->id[1] = byte[1];
+		type->chipsize = (unsigned long)(spl_dev->chipsize >> 20);
+		type->name = spl_dev->name;
+		return type;
+	}
+	nand_dev->read_retry_type = NAND_RR_NONE;
+
+	return NULL;
+}
+/*****************************************************************************/
+
+struct nand_flash_dev *hinfc_get_flash_type(struct mtd_info *mtd,
+					    struct nand_chip *chip,
+					    u8 *id_data, int *busw)
+{
+	struct nand_flash_dev *type;
+	struct nand_dev_t *nand_dev = &__nand_dev;
+
+	memset(nand_dev, 0, sizeof(struct nand_dev_t));
+	memcpy(nand_dev->ids, id_data, 8);
+
+	if (!hinfc_nand_probe(mtd, chip, nand_dev))
+		return NULL;
+
+	type = &nand_dev->flash_dev;
+
+	if (!mtd->name)
+		mtd->name = type->name;
+
+	chip->chipsize = (uint64_t)type->chipsize << 20;
+	mtd->erasesize = type->erasesize;
+	mtd->writesize = type->pagesize;
+	mtd->oobsize   = nand_dev->oobsize;
+	*busw = (type->options & NAND_BUSWIDTH_16);
+
+	return type;
+}
+/*****************************************************************************/
+
+void hinfc_nand_param_adjust(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	struct nand_dev_t *nand_dev = &__nand_dev;
+
+	if (!nand_dev->oobsize)
+		nand_dev->oobsize = mtd->oobsize;
+
+	if (hinfc_param_adjust)
+		hinfc_param_adjust(mtd, chip, nand_dev);
+}
+/*****************************************************************************/
+
+void hinfc_show_info(struct mtd_info *mtd, char *vendor, char *chipname)
+{
+	/* char buf[20]; */
+	struct nand_dev_t *nand_dev = &__nand_dev;
+
+	/* hinfc_pr_msg("Nand: %s %s ", vendor, chipname); */
+
+	if (IS_NAND_RANDOM(nand_dev))
+		hinfc_pr_msg("Randomizer \n");
+
+	if (nand_dev->read_retry_type != NAND_RR_NONE)
+		hinfc_pr_msg("Read-Retry \n");
+
+	if (nand_dev->start_type)
+		hinfc_pr_msg("Nand(%s): ", nand_dev->start_type);
+	else
+		hinfc_pr_msg("Nand: ");
+
+	hinfc_pr_msg("OOB:%dB ", nand_dev->oobsize);
+	hinfc_pr_msg("ECC:%s ", nand_ecc_name(nand_dev->ecctype));
+}
+/*****************************************************************************/
+
+void hinfc_show_chipsize(struct nand_chip *chip)
+{
+	/*char buf[20];*/
+
+	/*hinfc_pr_msg("Chip:%sB*%d\n",
+		     ultohstr(chip->chipsize, buf, sizeof(buf)),
+		     chip->numchips);*/
+}
diff -ruN linux-4.9.37_original/drivers/mtd/nand/Kconfig linux-4.9.37_modified/drivers/mtd/nand/Kconfig
--- linux-4.9.37_original/drivers/mtd/nand/Kconfig	2017-07-12 16:42:41.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/Kconfig	2018-07-04 07:50:03.075724383 +0300
@@ -569,4 +569,28 @@
 	  Enables support for NAND controller on MTK SoCs.
 	  This controller is found on mt27xx, mt81xx, mt65xx SoCs.
 
+config MTD_SPI_NAND_HISI_BVT
+    tristate "Support for SPI NAND controller on Hisilicon SoCs"
+    depends on MTD_NAND
+    help
+      Enables support for the SPI NAND device drivers.
+
+config HISI_NAND_ECC_STATUS_REPORT
+	tristate "Report the ecc status to MTD for HiSilicon Nand Driver"
+	depends on MFD_HISI_FMC
+	default n
+	help
+	  Flash Memory Controller V100 reports the ecc status include ECC error
+	  and ECC corrected to MTD to monitor the aging of devices.
+
+config HISI_NAND_FS_MAY_NO_YAFFS2
+    bool "Remove the restraintion of 16bit ecc type on yaffs2 to HiSilicon"
+	depends on MFD_HISI_FMC
+    default n
+    help
+      The ecc type: 16bit is limited by the HiSilicon flash memory controller,
+      as the yaffs2 tag of hisi rootfs limits the min size of CTRL len is 28.
+
+source "drivers/mtd/nand/hifmc100/Kconfig"
+
 endif # MTD_NAND
diff -ruN linux-4.9.37_original/drivers/mtd/nand/Makefile linux-4.9.37_modified/drivers/mtd/nand/Makefile
--- linux-4.9.37_original/drivers/mtd/nand/Makefile	2017-07-12 16:42:41.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/Makefile	2018-07-04 07:50:03.075724383 +0300
@@ -8,6 +8,7 @@
 obj-$(CONFIG_MTD_NAND_IDS)		+= nand_ids.o
 obj-$(CONFIG_MTD_SM_COMMON) 		+= sm_common.o
 
+obj-$(CONFIG_MTD_SPI_NAND_HIFMC100)	+= hifmc100/
 obj-$(CONFIG_MTD_NAND_CAFE)		+= cafe_nand.o
 obj-$(CONFIG_MTD_NAND_AMS_DELTA)	+= ams-delta.o
 obj-$(CONFIG_MTD_NAND_DENALI)		+= denali.o
@@ -59,4 +60,4 @@
 obj-$(CONFIG_MTD_NAND_QCOM)		+= qcom_nandc.o
 obj-$(CONFIG_MTD_NAND_MTK)		+= mtk_nand.o mtk_ecc.o
 
-nand-objs := nand_base.o nand_bbt.o nand_timings.o
+nand-objs := nand_base.o nand_bbt.o nand_timings.o hinfc_gen.o hinfc_spl_ids.o match_table.o
diff -ruN linux-4.9.37_original/drivers/mtd/nand/match_table.c linux-4.9.37_modified/drivers/mtd/nand/match_table.c
--- linux-4.9.37_original/drivers/mtd/nand/match_table.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/match_table.c	2018-07-04 07:50:03.083724463 +0300
@@ -0,0 +1,96 @@
+/******************************************************************************
+ *    COPYRIGHT (C) Hisilicon.2013
+ *    All rights reserved.
+ * ***
+ *    Create by Hisilicon 2013-08-15
+ *
+ *****************************************************************************/
+
+/*****************************************************************************/
+#include <linux/string.h>
+#include "match_table.h"
+
+/*****************************************************************************/
+int reg2type(struct match_reg_type *table, int length, int reg, int def)
+{
+	while (length-- > 0) {
+		if (table->reg == reg)
+			return table->type;
+		table++;
+	}
+	return def;
+}
+
+int type2reg(struct match_reg_type *table, int length, int type, int def)
+{
+	while (length-- > 0) {
+		if (table->type == type)
+			return table->reg;
+		table++;
+	}
+	return def;
+}
+
+int str2type(struct match_type_str *table, int length, const char *str,
+	     int size, int def)
+{
+	while (length-- > 0) {
+		if (!strncmp(table->str, str, size))
+			return table->type;
+		table++;
+	}
+	return def;
+}
+
+const char *type2str(struct match_type_str *table, int length, int type,
+		     const char *def)
+{
+	while (length-- > 0) {
+		if (table->type == type)
+			return table->str;
+		table++;
+	}
+	return def;
+}
+
+int match_reg_to_type(struct match_t *table, int nr_table, int reg, int def)
+{
+	while (nr_table-- > 0) {
+		if (table->reg == reg)
+			return table->type;
+		table++;
+	}
+	return def;
+}
+
+int match_type_to_reg(struct match_t *table, int nr_table, int type, int def)
+{
+	while (nr_table-- > 0) {
+		if (table->type == type)
+			return table->reg;
+		table++;
+	}
+	return def;
+}
+
+int match_data_to_type(struct match_t *table, int nr_table, char *data,
+		int size, int def)
+{
+	while (nr_table-- > 0) {
+		if (!memcmp(table->data, data, size))
+			return table->type;
+		table++;
+	}
+	return def;
+}
+
+void *match_type_to_data(struct match_t *table, int nr_table, int type,
+			 void *def)
+{
+	while (nr_table-- > 0) {
+		if (table->type == type)
+			return table->data;
+		table++;
+	}
+	return def;
+}
diff -ruN linux-4.9.37_original/drivers/mtd/nand/match_table.h linux-4.9.37_modified/drivers/mtd/nand/match_table.h
--- linux-4.9.37_original/drivers/mtd/nand/match_table.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/match_table.h	2018-07-04 07:50:03.083724463 +0300
@@ -0,0 +1,56 @@
+/******************************************************************************
+ *    COPYRIGHT (C) Hisilicon 2013
+ *    All rights reserved.
+ * ***
+ *    Create by Hisilicon 2013-08-15
+ *
+ *****************************************************************************/
+#ifndef __MATCH_TABLE_H__
+#define __MATCH_TABLE_H__
+
+/*****************************************************************************/
+struct match_reg_type {
+	int reg;
+	int type;
+};
+
+struct match_type_str {
+	int type;
+	const char *str;
+};
+
+struct match_t {
+	int type;
+	int reg;
+	void *data;
+};
+
+/*****************************************************************************/
+#define MATCH_SET_TYPE_REG(_type, _reg)   {(_type), (_reg), (void *)0}
+#define MATCH_SET_TYPE_DATA(_type, _data) {(_type), 0, (void *)(_data)}
+#define MATCH_SET(_type, _reg, _data)     {(_type), (_reg), (void *)(_data)}
+
+/*****************************************************************************/
+int reg2type(struct match_reg_type *table, int length, int reg, int def);
+
+int type2reg(struct match_reg_type *table, int length, int type, int def);
+
+int str2type(struct match_type_str *table, int length, const char *str,
+	     int size, int def);
+
+const char *type2str(struct match_type_str *table, int length, int type,
+		     const char *def);
+
+int match_reg_to_type(struct match_t *table, int nr_table, int reg, int def);
+
+int match_type_to_reg(struct match_t *table, int nr_table, int type, int def);
+
+int match_data_to_type(struct match_t *table, int nr_table, char *data,
+		int size, int def);
+
+void *match_type_to_data(struct match_t *table, int nr_table, int type,
+			 void *def);
+
+/*****************************************************************************/
+
+#endif /* End of __MATCH_TABLE_H__ */
diff -ruN linux-4.9.37_original/drivers/mtd/nand/nand_base.c linux-4.9.37_modified/drivers/mtd/nand/nand_base.c
--- linux-4.9.37_original/drivers/mtd/nand/nand_base.c	2017-07-12 16:42:41.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/nand_base.c	2018-07-04 07:50:03.087724502 +0300
@@ -47,6 +47,8 @@
 #include <linux/mtd/partitions.h>
 #include <linux/of.h>
 
+#include "hinfc_gen.h"
+
 static int nand_get_device(struct mtd_info *mtd, int new_state);
 
 static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
@@ -4077,7 +4079,7 @@
 						  int *maf_id, int *dev_id,
 						  struct nand_flash_dev *type)
 {
-	int busw;
+	int busw = 0;
 	int i, maf_idx;
 	u8 id_data[8];
 
@@ -4116,6 +4118,20 @@
 		return ERR_PTR(-ENODEV);
 	}
 
+#if defined(CONFIG_MTD_SPI_NAND_HIFMC100)
+	/* SPI Nand Flash*/
+	if (get_spi_nand_flash_type_hook)
+		type = get_spi_nand_flash_type_hook(mtd, id_data);
+
+	/* SPI Nand Flash only can support the devices on id table */
+	if (!type) {
+		pr_info("This device[%02x,%02x] cannot found in spi nand id table!!\n",
+				*maf_id, *dev_id);
+		return ERR_PTR(-ENODEV);
+	} else
+		goto ident_done;
+#endif
+
 	if (!type)
 		type = nand_flash_ids;
 
@@ -4163,6 +4179,9 @@
 	if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)
 		chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
 ident_done:
+#ifdef CONFIG_ARCH_HISI_BVT
+	hinfc_nand_param_adjust(mtd, chip);
+#endif
 
 	/* Try to identify manufacturer */
 	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
@@ -4224,9 +4243,13 @@
 		pr_info("%s %s\n", nand_manuf_ids[maf_idx].name,
 				type->name);
 
-	pr_info("%d MiB, %s, erase size: %d KiB, page size: %d, OOB size: %d\n",
+	pr_info("%dMiB, %s, page size: %d\n",
 		(int)(chip->chipsize >> 20), nand_is_slc(chip) ? "SLC" : "MLC",
-		mtd->erasesize >> 10, mtd->writesize, mtd->oobsize);
+		mtd->writesize);
+
+	/* Print ecc type and ecc mode about hisilicon flash controller */
+	hinfc_show_info(mtd, nand_manuf_ids[maf_idx].name, type->name);
+
 	return type;
 }
 
@@ -4746,7 +4769,7 @@
 		break;
 
 	case NAND_ECC_NONE:
-		pr_warn("NAND_ECC_NONE selected by board driver. This is not recommended!\n");
+		pr_warn(" ECC provided by Flash Memory Controller\n");
 		ecc->read_page = nand_read_page_raw;
 		ecc->write_page = nand_write_page_raw;
 		ecc->read_oob = nand_read_oob_std;
@@ -4838,8 +4861,13 @@
 		break;
 	}
 
+#ifdef CONFIG_MTD_UBI
+	/* mtd->type = MTD_MLCNANDFLASH isn't support by mtd_util ubi tools jet */
+	mtd->type = MTD_NANDFLASH;
+#else
 	/* Fill in remaining MTD driver data */
 	mtd->type = nand_is_slc(chip) ? MTD_NANDFLASH : MTD_MLCNANDFLASH;
+#endif
 	mtd->flags = (chip->options & NAND_ROM) ? MTD_CAP_ROM :
 						MTD_CAP_NANDFLASH;
 	mtd->_erase = nand_erase;
diff -ruN linux-4.9.37_original/drivers/mtd/nand/nand_ids.c linux-4.9.37_modified/drivers/mtd/nand/nand_ids.c
--- linux-4.9.37_original/drivers/mtd/nand/nand_ids.c	2017-07-12 16:42:41.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/nand/nand_ids.c	2018-07-04 07:50:03.087724502 +0300
@@ -168,7 +168,7 @@
 /* Manufacturer IDs */
 struct nand_manufacturers nand_manuf_ids[] = {
 	{NAND_MFR_TOSHIBA, "Toshiba"},
-	{NAND_MFR_ESMT, "ESMT"},
+	{NAND_MFR_GD_ESMT,	"GD/ESMT"},
 	{NAND_MFR_SAMSUNG, "Samsung"},
 	{NAND_MFR_FUJITSU, "Fujitsu"},
 	{NAND_MFR_NATIONAL, "National"},
@@ -179,9 +179,13 @@
 	{NAND_MFR_AMD, "AMD/Spansion"},
 	{NAND_MFR_MACRONIX, "Macronix"},
 	{NAND_MFR_EON, "Eon"},
+	{NAND_MFR_MXIC,		"MXIC"},
+	{NAND_MFR_ALL_FLASH,	"All-flash"},
+	{NAND_MFR_PARAGON,	"Paragon"},
+       {NAND_MFR_HEYANGTEK, "HeYangTek"},
 	{NAND_MFR_SANDISK, "SanDisk"},
 	{NAND_MFR_INTEL, "Intel"},
 	{NAND_MFR_ATO, "ATO"},
	{NAND_MFR_WINBOND, "Winbond"},
 	{0x0, "Unknown"}
 };
 
diff -ruN linux-4.9.37_original/drivers/mtd/spi-nor/hisi-sfc.c linux-4.9.37_modified/drivers/mtd/spi-nor/hisi-sfc.c
--- linux-4.9.37_original/drivers/mtd/spi-nor/hisi-sfc.c	2017-07-12 16:42:41.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/spi-nor/hisi-sfc.c	2018-07-04 07:50:03.087724502 +0300
@@ -16,80 +16,21 @@
  * You should have received a copy of the GNU General Public License
  * along with this program. If not, see <http://www.gnu.org/licenses/>.
  */
-#include <linux/bitops.h>
 #include <linux/clk.h>
 #include <linux/dma-mapping.h>
 #include <linux/iopoll.h>
 #include <linux/module.h>
+#include <linux/mfd/hisi_fmc.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/spi-nor.h>
+#include <linux/mtd/partitions.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 
-/* Hardware register offsets and field definitions */
-#define FMC_CFG				0x00
-#define FMC_CFG_OP_MODE_MASK		BIT_MASK(0)
-#define FMC_CFG_OP_MODE_BOOT		0
-#define FMC_CFG_OP_MODE_NORMAL		1
-#define FMC_CFG_FLASH_SEL(type)		(((type) & 0x3) << 1)
-#define FMC_CFG_FLASH_SEL_MASK		0x6
-#define FMC_ECC_TYPE(type)		(((type) & 0x7) << 5)
-#define FMC_ECC_TYPE_MASK		GENMASK(7, 5)
-#define SPI_NOR_ADDR_MODE_MASK		BIT_MASK(10)
-#define SPI_NOR_ADDR_MODE_3BYTES	(0x0 << 10)
-#define SPI_NOR_ADDR_MODE_4BYTES	(0x1 << 10)
-#define FMC_GLOBAL_CFG			0x04
-#define FMC_GLOBAL_CFG_WP_ENABLE	BIT(6)
-#define FMC_SPI_TIMING_CFG		0x08
-#define TIMING_CFG_TCSH(nr)		(((nr) & 0xf) << 8)
-#define TIMING_CFG_TCSS(nr)		(((nr) & 0xf) << 4)
-#define TIMING_CFG_TSHSL(nr)		((nr) & 0xf)
-#define CS_HOLD_TIME			0x6
-#define CS_SETUP_TIME			0x6
-#define CS_DESELECT_TIME		0xf
-#define FMC_INT				0x18
-#define FMC_INT_OP_DONE			BIT(0)
-#define FMC_INT_CLR			0x20
-#define FMC_CMD				0x24
-#define FMC_CMD_CMD1(cmd)		((cmd) & 0xff)
-#define FMC_ADDRL			0x2c
-#define FMC_OP_CFG			0x30
-#define OP_CFG_FM_CS(cs)		((cs) << 11)
-#define OP_CFG_MEM_IF_TYPE(type)	(((type) & 0x7) << 7)
-#define OP_CFG_ADDR_NUM(addr)		(((addr) & 0x7) << 4)
-#define OP_CFG_DUMMY_NUM(dummy)		((dummy) & 0xf)
-#define FMC_DATA_NUM			0x38
-#define FMC_DATA_NUM_CNT(cnt)		((cnt) & GENMASK(13, 0))
-#define FMC_OP				0x3c
-#define FMC_OP_DUMMY_EN			BIT(8)
-#define FMC_OP_CMD1_EN			BIT(7)
-#define FMC_OP_ADDR_EN			BIT(6)
-#define FMC_OP_WRITE_DATA_EN		BIT(5)
-#define FMC_OP_READ_DATA_EN		BIT(2)
-#define FMC_OP_READ_STATUS_EN		BIT(1)
-#define FMC_OP_REG_OP_START		BIT(0)
-#define FMC_DMA_LEN			0x40
-#define FMC_DMA_LEN_SET(len)		((len) & GENMASK(27, 0))
-#define FMC_DMA_SADDR_D0		0x4c
-#define HIFMC_DMA_MAX_LEN		(4096)
-#define HIFMC_DMA_MASK			(HIFMC_DMA_MAX_LEN - 1)
+#include "../mtdcore.h"
+
 #define FMC_OP_DMA			0x68
-#define OP_CTRL_RD_OPCODE(code)		(((code) & 0xff) << 16)
-#define OP_CTRL_WR_OPCODE(code)		(((code) & 0xff) << 8)
-#define OP_CTRL_RW_OP(op)		((op) << 1)
-#define OP_CTRL_DMA_OP_READY		BIT(0)
-#define FMC_OP_READ			0x0
-#define FMC_OP_WRITE			0x1
-#define FMC_WAIT_TIMEOUT		1000000
-
-enum hifmc_iftype {
-	IF_TYPE_STD,
-	IF_TYPE_DUAL,
-	IF_TYPE_DIO,
-	IF_TYPE_QUAD,
-	IF_TYPE_QIO,
-};
 
 struct hifmc_priv {
 	u32 chipselect;
@@ -97,10 +38,9 @@
 	struct hifmc_host *host;
 };
 
-#define HIFMC_MAX_CHIP_NUM		2
 struct hifmc_host {
 	struct device *dev;
-	struct mutex lock;
+	struct mutex *lock;
 
 	void __iomem *regbase;
 	void __iomem *iobase;
@@ -109,9 +49,11 @@
 	dma_addr_t dma_buffer;
 
 	struct spi_nor	*nor[HIFMC_MAX_CHIP_NUM];
+	struct hifmc_priv priv[HIFMC_MAX_CHIP_NUM];
 	u32 num_chip;
 };
 
+/******************************************************************************/
 static inline int wait_op_finish(struct hifmc_host *host)
 {
 	u32 reg;
@@ -120,19 +62,24 @@
 		(reg & FMC_INT_OP_DONE), 0, FMC_WAIT_TIMEOUT);
 }
 
-static int get_if_type(enum read_mode flash_read)
+static int get_if_type(enum spi_nor_protocol mode)
 {
 	enum hifmc_iftype if_type;
 
-	switch (flash_read) {
-	case SPI_NOR_DUAL:
+	switch (mode) {
+	case SNOR_PROTO_1_1_2:
 		if_type = IF_TYPE_DUAL;
 		break;
-	case SPI_NOR_QUAD:
+	case SNOR_PROTO_1_2_2:
+		if_type = IF_TYPE_DIO;
+		break;
+	case SNOR_PROTO_1_1_4:
 		if_type = IF_TYPE_QUAD;
 		break;
-	case SPI_NOR_NORMAL:
-	case SPI_NOR_FAST:
+	case SNOR_PROTO_1_4_4:
+		if_type = IF_TYPE_QIO;
+		break;
+	case SNOR_PROTO_1_1_1:
 	default:
 		if_type = IF_TYPE_STD;
 		break;
@@ -141,23 +88,47 @@
 	return if_type;
 }
 
+/******************************************************************************/
+static void spi_nor_switch_spi_type(struct hifmc_host *host)
+{
+	unsigned int reg;
+
+	reg = hifmc_readl(host, FMC_CFG);
+	reg &= ~FLASH_TYPE_SEL_MASK;
+	reg |= FMC_CFG_FLASH_SEL(0);
+	hifmc_writel(host, FMC_CFG, reg);
+}
+
+/******************************************************************************/
 static void hisi_spi_nor_init(struct hifmc_host *host)
 {
-	u32 reg;
+	unsigned int reg;
+
+	/* switch the flash type to spi nor */
+	spi_nor_switch_spi_type(host);
 
+	/* set the boot mode to normal */
+	reg = hifmc_readl(host, FMC_CFG);
+	if ((reg & FMC_CFG_OP_MODE_MASK) == FMC_CFG_OP_MODE_BOOT) {
+		reg |= FMC_CFG_OP_MODE(FMC_CFG_OP_MODE_NORMAL);
+		hifmc_writel(host, FMC_CFG, reg);
+	}
+
+	/* set timming */
 	reg = TIMING_CFG_TCSH(CS_HOLD_TIME)
 		| TIMING_CFG_TCSS(CS_SETUP_TIME)
 		| TIMING_CFG_TSHSL(CS_DESELECT_TIME);
-	writel(reg, host->regbase + FMC_SPI_TIMING_CFG);
+	hifmc_writel(host, FMC_SPI_TIMING_CFG, reg);
 }
 
+/******************************************************************************/
 static int hisi_spi_nor_prep(struct spi_nor *nor, enum spi_nor_ops ops)
 {
 	struct hifmc_priv *priv = nor->priv;
 	struct hifmc_host *host = priv->host;
 	int ret;
 
-	mutex_lock(&host->lock);
+	mutex_lock(host->lock);
 
 	ret = clk_set_rate(host->clk, priv->clkrate);
 	if (ret)
@@ -167,22 +138,26 @@
 	if (ret)
 		goto out;
 
+	spi_nor_switch_spi_type(host);
+
 	return 0;
 
 out:
-	mutex_unlock(&host->lock);
+	mutex_unlock(host->lock);
 	return ret;
 }
 
+/******************************************************************************/
 static void hisi_spi_nor_unprep(struct spi_nor *nor, enum spi_nor_ops ops)
 {
 	struct hifmc_priv *priv = nor->priv;
 	struct hifmc_host *host = priv->host;
 
 	clk_disable_unprepare(host->clk);
-	mutex_unlock(&host->lock);
+	mutex_unlock(host->lock);
 }
 
+/******************************************************************************/
 static int hisi_spi_nor_op_reg(struct spi_nor *nor,
 				u8 opcode, int len, u8 optype)
 {
@@ -191,21 +166,22 @@
 	u32 reg;
 
 	reg = FMC_CMD_CMD1(opcode);
-	writel(reg, host->regbase + FMC_CMD);
+	hifmc_writel(host, FMC_CMD, reg);
 
 	reg = FMC_DATA_NUM_CNT(len);
-	writel(reg, host->regbase + FMC_DATA_NUM);
+	hifmc_writel(host, FMC_DATA_NUM, reg);
 
 	reg = OP_CFG_FM_CS(priv->chipselect);
-	writel(reg, host->regbase + FMC_OP_CFG);
+	hifmc_writel(host, FMC_OP_CFG, reg);
 
-	writel(0xff, host->regbase + FMC_INT_CLR);
+	hifmc_writel(host, FMC_INT_CLR, 0xff);
 	reg = FMC_OP_CMD1_EN | FMC_OP_REG_OP_START | optype;
-	writel(reg, host->regbase + FMC_OP);
+	hifmc_writel(host, FMC_OP, reg);
 
 	return wait_op_finish(host);
 }
 
+/******************************************************************************/
 static int hisi_spi_nor_read_reg(struct spi_nor *nor, u8 opcode, u8 *buf,
 		int len)
 {
@@ -221,6 +197,7 @@
 	return 0;
 }
 
+/******************************************************************************/
 static int hisi_spi_nor_write_reg(struct spi_nor *nor, u8 opcode,
 				u8 *buf, int len)
 {
@@ -233,38 +210,51 @@
 	return hisi_spi_nor_op_reg(nor, opcode, len, FMC_OP_WRITE_DATA_EN);
 }
 
+/******************************************************************************/
 static int hisi_spi_nor_dma_transfer(struct spi_nor *nor, loff_t start_off,
 		dma_addr_t dma_buf, size_t len, u8 op_type)
 {
 	struct hifmc_priv *priv = nor->priv;
 	struct hifmc_host *host = priv->host;
-	u8 if_type = 0;
+	u8 if_type = 0, dummy = 0;
 	u32 reg;
 
-	reg = readl(host->regbase + FMC_CFG);
+	reg = hifmc_readl(host, FMC_CFG);
 	reg &= ~(FMC_CFG_OP_MODE_MASK | SPI_NOR_ADDR_MODE_MASK);
 	reg |= FMC_CFG_OP_MODE_NORMAL;
 	reg |= (nor->addr_width == 4) ? SPI_NOR_ADDR_MODE_4BYTES
 		: SPI_NOR_ADDR_MODE_3BYTES;
-	writel(reg, host->regbase + FMC_CFG);
+	hifmc_writel(host, FMC_CFG, reg);
+
+	hifmc_writel(host, FMC_ADDRL, start_off);
+
+	reg = (unsigned int)dma_buf;
+	hifmc_writel(host, FMC_DMA_SADDR_D0, reg);
 
-	writel(start_off, host->regbase + FMC_ADDRL);
-	writel(dma_buf, host->regbase + FMC_DMA_SADDR_D0);
-	writel(FMC_DMA_LEN_SET(len), host->regbase + FMC_DMA_LEN);
+#ifdef CONFIG_64BIT
+	reg = (dma_buf & FMC_DMA_SADDRH_MASK) >> 32;
+	hifmc_writel(host, FMC_DMA_SADDRH_D0, reg);
+#endif
+
+	hifmc_writel(host, FMC_DMA_LEN, FMC_DMA_LEN_SET(len));
 
 	reg = OP_CFG_FM_CS(priv->chipselect);
-	if_type = get_if_type(nor->flash_read);
-	reg |= OP_CFG_MEM_IF_TYPE(if_type);
-	if (op_type == FMC_OP_READ)
-		reg |= OP_CFG_DUMMY_NUM(nor->read_dummy >> 3);
-	writel(reg, host->regbase + FMC_OP_CFG);
+	if (op_type == FMC_OP_READ) {
+		if_type = get_if_type(nor->read_proto);
+		dummy = nor->read_dummy >> 3;
+	} else {
+		if_type = get_if_type(nor->write_proto);
+	}
+	reg |= OP_CFG_MEM_IF_TYPE(if_type)
+		| OP_CFG_DUMMY_NUM(dummy);
+	hifmc_writel(host, FMC_OP_CFG, reg);
 
-	writel(0xff, host->regbase + FMC_INT_CLR);
+	hifmc_writel(host, FMC_INT_CLR, 0xff);
 	reg = OP_CTRL_RW_OP(op_type) | OP_CTRL_DMA_OP_READY;
 	reg |= (op_type == FMC_OP_READ)
 		? OP_CTRL_RD_OPCODE(nor->read_opcode)
 		: OP_CTRL_WR_OPCODE(nor->program_opcode);
-	writel(reg, host->regbase + FMC_OP_DMA);
+	hifmc_writel(host, FMC_OP_DMA, reg);
 
 	return wait_op_finish(host);
 }
@@ -316,6 +306,26 @@
 }
 
 /**
+ * parse partitions info and register spi flash device as mtd device.
+ */
+static int hisi_snor_device_register(struct mtd_info *mtd)
+{
+	int ret;
+	struct mtd_partitions parsed;
+
+	/*
+	 * We do not add the whole spi flash as a mtdblock device,
+	 * To avoid the number of nand partition +1.
+	 */
+	memset(&parsed, 0, sizeof(parsed));
+	ret = parse_mtd_partitions(mtd, NULL, &parsed, NULL);
+	if (ret)
+		return ret;
+
+	return parsed.nr_parts ? mtd_device_register(mtd, NULL, 0) : parsed.nr_parts;
+}
+
+/**
  * Get spi flash device information and register it as a mtd device.
  */
 static int hisi_spi_nor_register(struct device_node *np,
@@ -323,9 +333,13 @@
 {
 	struct device *dev = host->dev;
 	struct spi_nor *nor;
-	struct hifmc_priv *priv;
+	struct hifmc_priv *priv = &host->priv[host->num_chip];
 	struct mtd_info *mtd;
 	int ret;
+	struct spi_nor_modes modes = {
+		.rd_modes = SNOR_MODE_SLOW,
+		.wr_modes = SNOR_MODE_1_1_1,
+	};
 
 	nor = devm_kzalloc(dev, sizeof(*nor), GFP_KERNEL);
 	if (!nor)
@@ -345,6 +359,13 @@
 		return ret;
 	}
 
+	if (priv->chipselect != host->num_chip) {
+		dev_warn(dev, " The CS: %d states in device trees isn't real " \
+				"chipselect on board\n, using CS: %d instead. ",
+				priv->chipselect, host->num_chip);
+		priv->chipselect = host->num_chip;
+	}
+
 	ret = of_property_read_u32(np, "spi-max-frequency",
 			&priv->clkrate);
 	if (ret) {
@@ -361,19 +382,27 @@
 	nor->write_reg = hisi_spi_nor_write_reg;
 	nor->read = hisi_spi_nor_read;
 	nor->write = hisi_spi_nor_write;
-	nor->erase = NULL;
-	ret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);
+
+	modes.rd_modes |= SNOR_MODE_1_1_1
+			| SNOR_MODE_1_1_2
+			| SNOR_MODE_1_2_2;
+#ifndef CONFIG_CLOSE_SPI_8PIN_4IO
+	modes.rd_modes |= SNOR_MODE_1_1_4 | SNOR_MODE_1_4_4;
+	modes.wr_modes |= SNOR_MODE_1_1_4 | SNOR_MODE_1_4_4;
+#endif
+	ret = spi_nor_scan(nor, NULL, &modes);
 	if (ret)
 		return ret;
 
 	mtd = &nor->mtd;
 	mtd->name = np->name;
-	ret = mtd_device_register(mtd, NULL, 0);
+	ret = hisi_snor_device_register(mtd);
 	if (ret)
 		return ret;
 
+	/* current chipselect has scanned, to detect next chipselect */
+	hifmc_cs_user[host->num_chip]++;
 	host->nor[host->num_chip] = nor;
-	host->num_chip++;
 	return 0;
 }
 
@@ -388,18 +417,27 @@
 static int hisi_spi_nor_register_all(struct hifmc_host *host)
 {
 	struct device *dev = host->dev;
-	struct device_node *np;
+	struct device_node *np = NULL;
 	int ret;
 
 	for_each_available_child_of_node(dev->of_node, np) {
+		if (hifmc_cs_user[host->num_chip]) {
+			dev_warn(dev, "Current CS(%d) is occupied.\n",
+					host->num_chip);
+			continue;
+		}
 		ret = hisi_spi_nor_register(np, host);
 		if (ret)
 			goto fail;
 
 		if (host->num_chip == HIFMC_MAX_CHIP_NUM) {
-			dev_warn(dev, "Flash device number exceeds the maximum chipselect number\n");
+			dev_warn(dev, "Flash device number exceeds the "
+					"maximum chipselect number\n");
 			break;
 		}
+
+		host->num_chip++;
+
 	}
 
 	return 0;
@@ -409,10 +447,11 @@
 	return ret;
 }
 
+/******************************************************************************/
 static int hisi_spi_nor_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-	struct resource *res;
+	struct hisi_fmc *fmc = dev_get_drvdata(dev->parent);
 	struct hifmc_host *host;
 	int ret;
 
@@ -423,19 +462,10 @@
 	platform_set_drvdata(pdev, host);
 	host->dev = dev;
 
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "control");
-	host->regbase = devm_ioremap_resource(dev, res);
-	if (IS_ERR(host->regbase))
-		return PTR_ERR(host->regbase);
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "memory");
-	host->iobase = devm_ioremap_resource(dev, res);
-	if (IS_ERR(host->iobase))
-		return PTR_ERR(host->iobase);
-
-	host->clk = devm_clk_get(dev, NULL);
-	if (IS_ERR(host->clk))
-		return PTR_ERR(host->clk);
+	host->regbase = fmc->regbase;
+	host->iobase = fmc->iobase;
+	host->clk = fmc->clk;
+	host->lock = &fmc->lock;
 
 	ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));
 	if (ret) {
@@ -448,40 +478,116 @@
 	if (!host->buffer)
 		return -ENOMEM;
 
-	mutex_init(&host->lock);
 	clk_prepare_enable(host->clk);
 	hisi_spi_nor_init(host);
 	ret = hisi_spi_nor_register_all(host);
 	if (ret)
-		mutex_destroy(&host->lock);
+		dev_warn(dev, "spi nor register fail!\n");
 
 	clk_disable_unprepare(host->clk);
+
 	return ret;
 }
 
+/******************************************************************************/
 static int hisi_spi_nor_remove(struct platform_device *pdev)
 {
 	struct hifmc_host *host = platform_get_drvdata(pdev);
 
 	hisi_spi_nor_unregister_all(host);
-	mutex_destroy(&host->lock);
 	clk_disable_unprepare(host->clk);
 	return 0;
 }
 
+/******************************************************************************/
+static void hisi_spi_nor_driver_shutdown(struct platform_device *pdev)
+{
+	int i;
+	struct hifmc_host *host = platform_get_drvdata(pdev);
+
+	if (!host)
+		return;
+
+	mutex_lock(host->lock);
+	clk_prepare_enable(host->clk);
+
+	spi_nor_switch_spi_type(host);
+	for (i = 0; i < host->num_chip; i++)
+		spi_nor_driver_shutdown(host->nor[i]);
+
+	clk_disable_unprepare(host->clk);
+	mutex_unlock(host->lock);
+	dev_dbg(host->dev, "End of driver shutdown\n");
+}
+
+#ifdef CONFIG_PM
+/******************************************************************************/
+static int hisi_spi_nor_driver_suspend(struct platform_device *pdev,
+		pm_message_t state)
+{
+	int i;
+	struct hifmc_host *host = platform_get_drvdata(pdev);
+
+	if (!host)
+		return 0;
+
+	mutex_lock(host->lock);
+	clk_prepare_enable(host->clk);
+
+	spi_nor_switch_spi_type(host);
+	for (i = 0; i < host->num_chip; i++)
+		spi_nor_suspend(host->nor[i], state);
+
+	clk_disable_unprepare(host->clk);
+	mutex_unlock(host->lock);
+	dev_dbg(host->dev, "End of suspend\n");
+
+	return 0;
+}
+
+/******************************************************************************/
+static int hisi_spi_nor_driver_resume(struct platform_device *pdev)
+{
+	int i;
+	struct hifmc_host *host = platform_get_drvdata(pdev);
+
+	if (!host)
+		return 0;
+
+	mutex_lock(host->lock);
+	clk_prepare_enable(host->clk);
+
+	spi_nor_switch_spi_type(host);
+	for (i = 0; i < host->num_chip; i++)
+		spi_nor_resume(host->nor[i]);
+
+	mutex_unlock(host->lock);
+	dev_dbg(host->dev, "End of resume\n");
+
+	return 0;
+}
+#endif /* End of CONFIG_PM */
+
+/******************************************************************************/
 static const struct of_device_id hisi_spi_nor_dt_ids[] = {
 	{ .compatible = "hisilicon,fmc-spi-nor"},
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, hisi_spi_nor_dt_ids);
 
+/******************************************************************************/
 static struct platform_driver hisi_spi_nor_driver = {
 	.driver = {
 		.name	= "hisi-sfc",
 		.of_match_table = hisi_spi_nor_dt_ids,
 	},
-	.probe	= hisi_spi_nor_probe,
-	.remove	= hisi_spi_nor_remove,
+	.probe		= hisi_spi_nor_probe,
+	.remove		= hisi_spi_nor_remove,
+	.shutdown	= hisi_spi_nor_driver_shutdown,
+#ifdef CONFIG_PM
+	.suspend	= hisi_spi_nor_driver_suspend,
+	.resume		= hisi_spi_nor_driver_resume,
+#endif
 };
 module_platform_driver(hisi_spi_nor_driver);
 
diff -ruN linux-4.9.37_original/drivers/mtd/spi-nor/Kconfig linux-4.9.37_modified/drivers/mtd/spi-nor/Kconfig
--- linux-4.9.37_original/drivers/mtd/spi-nor/Kconfig	2017-07-12 16:42:41.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/spi-nor/Kconfig	2018-07-04 07:50:03.087724502 +0300
@@ -59,11 +59,12 @@
 	  SPI NOR.
 
 config SPI_HISI_SFC
-	tristate "Hisilicon SPI-NOR Flash Controller(SFC)"
-	depends on ARCH_HISI || COMPILE_TEST
+	tristate "Hisilicon FMCV100 SPI-NOR Flash Controller(SFC)"
+	depends on ARCH_HISI || ARCH_HISI_BVT || COMPILE_TEST
 	depends on HAS_IOMEM && HAS_DMA
 	help
-	  This enables support for hisilicon SPI-NOR flash controller.
+	  This enables support for hisilicon flash memory contrller ver100
+	  (FMCV100)- SPI-NOR flash controller.
 
 config SPI_NXP_SPIFI
 	tristate "NXP SPI Flash Interface (SPIFI)"
@@ -76,4 +77,32 @@
 	  Flash. Enable this option if you have a device with a SPIFI
 	  controller and want to access the Flash as a mtd device.
 
+config MTD_SPI_IDS
+    bool "SPI Flash Timing Cycles Probe Function"
+    default n
+    help
+      This option enables hisfc300 used spi flash timing cylces
+      probe function.
+      If your use hisfc300, this function should be select.
+
+config CLOSE_SPI_8PIN_4IO
+	bool "Close SPI device Quad SPI mode for some 8PIN chip"
+	default y if ARCH_HISI_BVT
+	help
+	Hifmcv100 and Hisfcv350 support Quad SPI mode and Quad&addr SPI mode.
+	But some 8PIN chip does not support this mode when HOLD/IO3 PIN
+	was used by reset operation.
+	Usually, your should not config this option.
+
+config HISI_SPI_BLOCK_PROTECT
+	bool "Hisilicon Spi Nor Device BP(Block Protect) Support"
+	depends on SPI_HISI_SFC
+	default y if SPI_HISI_SFC
+	help
+	  HISI SFC supports BP(Block Protect) feature to preestablish a series
+	  area to avoid writing and erasing, except to reading. With this macro
+	  definition we can get the BP info which was setted before. The
+	  BOTTOM/TOP bit is setted to BOTTOM, it means the lock area starts
+	  from 0 address.
+
 endif # MTD_SPI_NOR
diff -ruN linux-4.9.37_original/drivers/mtd/spi-nor/Makefile linux-4.9.37_modified/drivers/mtd/spi-nor/Makefile
--- linux-4.9.37_original/drivers/mtd/spi-nor/Makefile	2017-07-12 16:42:41.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/spi-nor/Makefile	2018-07-04 07:50:03.087724502 +0300
@@ -5,3 +5,5 @@
 obj-$(CONFIG_SPI_HISI_SFC)	+= hisi-sfc.o
 obj-$(CONFIG_MTD_MT81xx_NOR)    += mtk-quadspi.o
 obj-$(CONFIG_SPI_NXP_SPIFI)	+= nxp-spifi.o
+
+obj-$(CONFIG_MTD_SPI_IDS)   += spi_ids.o
diff -ruN linux-4.9.37_original/drivers/mtd/spi-nor/spi_ids.c linux-4.9.37_modified/drivers/mtd/spi-nor/spi_ids.c
--- linux-4.9.37_original/drivers/mtd/spi-nor/spi_ids.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/spi-nor/spi_ids.c	2018-07-04 07:50:03.091724541 +0300
@@ -0,0 +1,254 @@
+/*
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <asm/setup.h>
+
+#include "spi_ids.h"
+
+#define SPI_DRV_VERSION       "1.22"
+/*****************************************************************************/
+
+#if 1
+#  define DBG_MSG(_fmt, arg...)
+#else
+#  define DBG_MSG(_fmt, arg...)   \
+	printk(KERN_DEBUG "%s(%d): " _fmt, __FILE__, __LINE__, ##arg);
+#endif
+
+#define DBG_BUG(fmt, args...) do {\
+	printk(KERN_DEBUG "%s(%d): BUG !!! " fmt, __FILE__, __LINE__, ##args); \
+	while (1)\
+		;\
+} while (0)
+
+/*****************************************************************************/
+static char *int_to_size(unsigned long long size)
+{
+	int ix;
+	static char buffer[20];
+	char *fmt[] = {"%u", "%uK", "%uM", "%uG", "%uT", "%uT"};
+
+	for (ix = 0; (ix < 5) && !(size & 0x3FF) && size; ix++)
+		size = (size >> 10);
+
+	sprintf(buffer, fmt[ix], size);
+	return buffer;
+}
+/*****************************************************************************/
+
+struct spi_info *spi_serach_ids(unsigned char ids[8])
+{
+	struct spi_info *info;
+	struct spi_info *fit_info = NULL;
+
+	for (info = spi_info_table; info->name; info++) {
+		if (memcmp(info->id, ids, info->id_len))
+			continue;
+
+		if ((fit_info == NULL) || (fit_info->id_len < info->id_len))
+			fit_info = info;
+	}
+	return fit_info;
+}
+/*****************************************************************************/
+
+void spi_search_rw(struct spi_info *spiinfo, struct spi_operation *spiop_rw,
+	unsigned int iftype, unsigned int max_dummy, int is_read)
+{
+	int ix = 0;
+	struct spi_operation **spiop, **fitspiop;
+
+	for (fitspiop = spiop = (is_read ? spiinfo->read : spiinfo->write);
+		(*spiop) && ix < MAX_SPI_OP; spiop++, ix++) {
+		DBG_MSG("dump[%d] %s iftype:0x%02X\n", ix,
+			(is_read ? "read" : "write"),
+			(*spiop)->iftype);
+
+		if (((*spiop)->iftype & iftype)
+			&& ((*spiop)->dummy <= max_dummy)
+			&& (*fitspiop)->iftype < (*spiop)->iftype) {
+			fitspiop = spiop;
+		}
+	}
+	memcpy(spiop_rw, (*fitspiop), sizeof(struct spi_operation));
+}
+/*****************************************************************************/
+#ifndef CONFIG_MTD_HISFC300
+void spi_get_erase(struct spi_info *spiinfo, struct spi_operation *spiop_erase)
+{
+	int ix;
+
+	spiop_erase->size = 0;
+	for (ix = 0; ix < MAX_SPI_OP; ix++) {
+		if (spiinfo->erase[ix] == NULL)
+			break;
+		if (spiinfo->erasesize == spiinfo->erase[ix]->size) {
+			memcpy(&spiop_erase[ix], spiinfo->erase[ix],
+			sizeof(struct spi_operation));
+
+			break;
+		}
+	}
+}
+#endif
+/*****************************************************************************/
+
+struct spi_tag {
+	char name[16];
+
+	unsigned char  id[8];
+	unsigned int   id_len;
+
+	unsigned long  chipsize;
+	unsigned int   erasesize;
+	unsigned int   addrcycle;
+
+	struct spi_operation read[MAX_SPI_OP];
+	struct spi_operation write[MAX_SPI_OP];
+	struct spi_operation erase[MAX_SPI_OP];
+};
+/*****************************************************************************/
+
+static int __init parse_spi_id(const struct tag *tag)
+{
+	int ix;
+	static struct spi_tag spitag[1];
+	struct spi_info *spiinfo = spi_info_table;
+
+	if (tag->hdr.size < ((sizeof(struct tag_header) +
+					sizeof(struct spi_tag)) >> 2)) {
+		printk(KERN_ERR "%s(%d):tag->hdr.size(%d) too small.\n",
+			__func__, __LINE__, tag->hdr.size);
+		return 0;
+	}
+	memset(spiinfo, 0, sizeof(struct spi_info));
+	memcpy(spitag, &tag->u, sizeof(struct spi_tag));
+
+	spiinfo->name = spitag->name;
+
+	memcpy(spiinfo->id, spitag->id, 8);
+	spiinfo->id_len = spitag->id_len;
+
+	spiinfo->chipsize = spitag->chipsize;
+	spiinfo->erasesize = spitag->erasesize;
+	spiinfo->addrcycle = spitag->addrcycle;
+
+	for (ix = 0; ix < MAX_SPI_OP; ix++) {
+		if (spitag->read[ix].iftype)
+			spiinfo->read[ix] = &spitag->read[ix];
+	}
+	for (ix = 0; ix < MAX_SPI_OP; ix++) {
+		if (spitag->write[ix].iftype)
+			spiinfo->write[ix] = &spitag->write[ix];
+	}
+	for (ix = 0; ix < MAX_SPI_OP; ix++) {
+		if (spitag->erase[ix].iftype)
+			spiinfo->erase[ix] = &spitag->erase[ix];
+	}
+
+	printk(KERN_NOTICE "SPI TAG: hdr.tag: 0x%08X, hdr.size: %d\n",
+		tag->hdr.tag, tag->hdr.size);
+	printk(KERN_NOTICE "(%dByte): 0x%02X 0x%02X 0x%02X 0x%02X "
+			"0x%02X 0x%02X 0x%02X 0x%02X\n",
+		spitag->id_len,
+		spitag->id[0], spitag->id[1], spitag->id[2], spitag->id[3],
+		spitag->id[4], spitag->id[5], spitag->id[6], spitag->id[7]);
+	printk(KERN_NOTICE "Block:%sB ",     int_to_size(spitag->erasesize));
+	printk(KERN_NOTICE "Chip:%sB ",      int_to_size(spitag->chipsize));
+	printk(KERN_NOTICE "AddrCycle:%d ",  spitag->addrcycle);
+	printk(KERN_NOTICE "Name:(%s)",      spitag->name);
+	printk(KERN_NOTICE "\n");
+	for (ix = 0; ix < MAX_SPI_OP; ix++) {
+		if (spitag->read[ix].iftype) {
+			printk(KERN_NOTICE "R %d: ", ix + 1);
+			printk(KERN_NOTICE "IF Type:0x%02X ",
+					spitag->read[ix].iftype);
+			printk(KERN_NOTICE "CMD:0x%02X ",
+					spitag->read[ix].cmd);
+			printk(KERN_NOTICE "Dummy:%d ",
+					spitag->read[ix].dummy);
+			if (spitag->read[ix].size == INFINITE)
+				printk(KERN_NOTICE "Size:-1      ");
+			else
+				printk(KERN_NOTICE "Size:%6sB ",
+					int_to_size(spitag->read[ix].size));
+			printk(KERN_NOTICE "Clock:%dMHz ",
+					spitag->read[ix].clock);
+			printk(KERN_NOTICE "\n");
+		}
+	}
+	for (ix = 0; ix < MAX_SPI_OP; ix++) {
+		if (spitag->write[ix].iftype) {
+			printk(KERN_NOTICE "W %d: ", ix + 1);
+			printk(KERN_NOTICE "IF Type:0x%02X ",
+					spitag->write[ix].iftype);
+			printk(KERN_NOTICE "CMD:0x%02X ",
+					spitag->write[ix].cmd);
+			printk(KERN_NOTICE "Dummy:%d ",
+					spitag->write[ix].dummy);
+			printk(KERN_NOTICE "Size:%6sB ",
+					int_to_size(spitag->write[ix].size));
+			printk(KERN_NOTICE "Clock:%dMHz ",
+					spitag->write[ix].clock);
+			printk(KERN_NOTICE "\n");
+		}
+	}
+	for (ix = 0; ix < MAX_SPI_OP; ix++) {
+		if (spitag->erase[ix].iftype) {
+			printk(KERN_NOTICE "E %d: ", ix + 1);
+			printk(KERN_NOTICE "IF Type:0x%02X ",
+					spitag->erase[ix].iftype);
+			printk(KERN_NOTICE "CMD:0x%02X ",
+					spitag->erase[ix].cmd);
+			printk(KERN_NOTICE "Dummy:%d ",
+					spitag->erase[ix].dummy);
+			printk(KERN_NOTICE "Size:0x%02X ",
+					spitag->erase[ix].size);
+			printk(KERN_NOTICE "Clock:%dMHz ",
+					spitag->erase[ix].clock);
+			printk(KERN_NOTICE "\n");
+		}
+	}
+
+	return 0;
+}
+
+/* turn to ascii is "S_ID" */
+__tagtable(0x535F4944, parse_spi_id);
+/*****************************************************************************/
+
+static int __init spi_ids_init(void)
+{
+	printk(KERN_INFO "Spi id table Version %s\n", SPI_DRV_VERSION);
+	return 0;
+}
+/*****************************************************************************/
+
+static void __exit spi_ids_exit(void)
+{
+}
+/*****************************************************************************/
+
+module_init(spi_ids_init);
+module_exit(spi_ids_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Spi id table");
diff -ruN linux-4.9.37_original/drivers/mtd/spi-nor/spi_ids.h linux-4.9.37_modified/drivers/mtd/spi-nor/spi_ids.h
--- linux-4.9.37_original/drivers/mtd/spi-nor/spi_ids.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-4.9.37_modified/drivers/mtd/spi-nor/spi_ids.h	2018-07-04 07:50:03.091724541 +0300
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) 2016 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef SPI_IDSH
+#define SPI_IDSH
+
+/*****************************************************************************/
+
+#define _1K		(0x400)
+#define _2K		(0x800)
+
+#define _4K		(0x1000)
+#define _8K		(0x2000)
+#define _16K		(0x4000)
+#define _32K		(0x8000)
+
+#define _64K		(0x10000)
+#define _128K		(0x20000)
+#define _256K		(0x40000)
+#define _512K		(0x80000)
+
+#define _1M		(0x100000)
+#define _2M		(0x200000)
+#define _4M		(0x400000)
+#define _8M		(0x800000)
+
+#define _16M		(0x1000000)
+#define _32M		(0x2000000)
+#define _64M		(0x4000000)
+
+#define INFINITE	(0xFFFFFFFF)
+/*****************************************************************************/
+
+#define SPI_IF_READ_STD			(0x01)
+#define SPI_IF_READ_FAST		(0x02)
+#define SPI_IF_READ_DUAL		(0x04)
+#define SPI_IF_READ_DUAL_ADDR		(0x08)
+#define SPI_IF_READ_QUAD		(0x10)
+#define SPI_IF_READ_QUAD_ADDR		(0x20)
+
+#define SPI_IF_WRITE_STD		(0x01)
+#define SPI_IF_WRITE_DUAL		(0x02)
+#define SPI_IF_WRITE_DUAL_ADDR		(0x04)
+#define SPI_IF_WRITE_QUAD		(0x08)
+#define SPI_IF_WRITE_QUAD_ADDR		(0x10)
+
+#define SPI_IF_ERASE_SECTOR		(0x01)	/* sector erase, 64K */
+#define SPI_IF_ERASE_CHIP		(0x02)	/* chip erase */
+#define SPI_IF_ERASE_4K			(0x04)	/* 4K */
+#define SPI_IF_ERASE_8K			(0x08)	/* 8K */
+
+#define SPI_IF_ERASE_SECTOR_4K		(0x01)	/* 4K */
+#define SPI_IF_ERASE_SECTOR_32K		(0x02)	/* 32K */
+#define SPI_IF_ERASE_SECTOR_64K		(0x04)	/* 64K */
+#define SPI_IF_ERASE_SECTOR_128K	(0x08)  /* 128K */
+#define SPI_IF_ERASE_SECTOR_256K	(0x10)  /* 256K */
+/*****************************************************************************/
+#define SPI_CMD_BRWR           (0x17)  /*write value to BAR*/
+#define SPI_EN4B_VALUE         (0x80)  /*the enable 4Byte addr len value*/
+#define SPI_EX4B_VALUE         (0x00)  /*the disable 4Byte addr len value*/
+#define SPI_4BYTE_ADDR_LEN     (4)     /*address len 4Byte*/
+/*****************************************************************************/
+
+#define SPI_CMD_WREN			0x06   /* Write Enable */
+#define SPI_CMD_WRDI			0x04   /* Write Disable */
+/*****************************************************************************/
+#define SPI_CMD_SE_4K			0x20	/* 4KB sector Erase */
+#define SPI_CMD_SE_32K			0x52	/* 32KB sector Erase */
+
+#define SPI_CMD_SE_64K			0xD8	/* 64KB sector Erase */
+#define SPI_CMD_SE_128K			0xD8   /* 128KB sector Erase */
+#define SPI_CMD_SE_256K			0xD8	/* 256KB sector Erase */
+
+#define SPI_CMD_SE			0xD8	/* 64KB Sector Erase */
+#define SPI_CMD_BE			0xC7	/* chip erase */
+/*****************************************************************************/
+#define SPI_CMD_WRSR			0x01	/* Write Status Register */
+#define SPI_CMD_WRSR2			0x31	/* Write Status Register-2 */
+#define SPI_CMD_WRSR3			0x11	/* Write Status Register-3 */
+
+#define SPI_CMD_RDSR			0x05	/* Read Status Register */
+#define SPI_CMD_RDSR2			0x35	/* Read Status Register-2 */
+#define SPI_CMD_RDSR3			0x15	/* Read Status Register-3 */
+
+#define SPI_CMD_RDCR			0x35	/* Read Config Register */
+
+#define SPI_CMD_RDID			0x9F	/* Read Identification */
+/*****************************************************************************/
+#define SPI_CMD_PP			0x02	/* Page Programming */
+#define SPI_CMD_WRITE_DUAL		0xA2	/* fast program dual input */
+#define SPI_CMD_WRITE_QUAD		0x32	/* fast program quad input */
+#define SPI_CMD_WRITE_DUAL_ADDR	0xD2	/* Dual I/O High Performance Write */
+#define SPI_CMD_WRITE_QUAD_ADDR	0x38	/* Quad I/O High Performance Write */
+/* #define SPI_CMD_WRITE_QUAD_ADDR	0x12	Quad I/O High Performance Write */
+/*****************************************************************************/
+#define SPI_CMD_READ			0x03	/* Read Data bytes */
+#define SPI_CMD_FAST_READ	0x0B	/* Read Data Bytes at Higher Speed */
+#define SPI_CMD_READ_DUAL		0x3B	/* fast read dual output */
+#define SPI_CMD_READ_QUAD		0x6B	/* fast read quad output */
+#define SPI_CMD_READ_DUAL_ADDR	0xBB	/* Dual I/O High Performance Read */
+#define SPI_CMD_READ_QUAD_ADDR	0xEB	/* Quad I/O High Performance Read */
+/*****************************************************************************/
+#define SPI_CMD_SR_WIP			1	/* Write in Progress */
+#define SPI_CMD_SR_WEL			2	/* Write Enable Latch */
+
+#define SPI_CMD_SR_QE			(1 << 9)	/* quad enable */
+#define SPI_CMD_SR_XQE			(0 << 9)	/* quad disable */
+/*****************************************************************************/
+#define SPI_CMD_EN4B			0xB7	/* enter to 4 bytes mode and
+							set 4 byte bit as '1' */
+#define SPI_CMD_EX4B			0xE9	/* exit 4 bytes mode and
+						clear 4 byte bit as '0' */
+
+/*****************************************************************************/
+
+struct spi_operation {
+	unsigned char	iftype;
+	unsigned char	cmd;
+	unsigned char	dummy;
+	unsigned int	size;
+	unsigned int	clock;
+};
+
+struct spi_info {
+	char *name;
+
+	unsigned char	id[8];
+	unsigned int	id_len;
+
+	unsigned long	chipsize;
+	unsigned int	erasesize;
+	unsigned int	addrcycle;
+
+#define MAX_SPI_OP                       (8)
+	struct spi_operation *read[8];
+	struct spi_operation *write[8];
+	struct spi_operation *erase[8];
+#ifndef CONFIG_MTD_HISFC300
+	struct spi_driver *driver;
+#endif
+};
+/*****************************************************************************/
+
+struct spi_info *spi_serach_ids(unsigned char ids[8]);
+
+void spi_search_rw(struct spi_info *spiinfo, struct spi_operation *spiop_rw,
+		unsigned int iftype, unsigned int max_dummy, int is_read);
+
+#ifndef CONFIG_MTD_HISFC300
+void spi_get_erase(struct spi_info *spiinfo, struct spi_operation *spiop_erase);
+#endif
+/******************************************************************************/
+
+extern struct spi_info spi_info_table[];
+/******************************************************************************/
+#endif /* SPI_IDSH */
